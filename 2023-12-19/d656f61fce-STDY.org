#+INCLUDE: "../../prefix.org"

#+TITLE: workqueue工作队列

REFERENCE: https://blog.csdn.net/u013253075/article/details/128396565
* 为什么需要工作队列?
内核代码中，经常遇到不能或不合适去马上调用某个处理过程，此时希望将该工作推送给某个
内核线程执行，这样做的原因有很多，比如：
- 中断触发了某个过程的执行条件，而该过程执行时间较长或者调用导致睡眠函数，则该过程
  不应该在中断上下文立即被调用。
- 类似于中断，一些紧急的任务不希望执行比较耗时的非关键过程，则需要把该过程提交到低
  优先级线程执行。比如一个轮询的通信接收线程，它需要快速完成检测和接收数据，而对数
  据解析则应该交由低优先级线程慢慢处理。
- 有时候希望将一些工作集中起来以获取批处理的性能；或则合并缩减一些执行线程，减少
  资源消耗。
- 基于以上需求，人们开发出了工作队列这一机制。工作队列不光在操作系统内核中会用到，
  一些应用程序或协议栈也会实现的工作队列。

* 工作队列的概念
*工作队列* 是将操作(或回调)延期异步执行的一种机制。工作队列可以把工作推后，交由一个
内核线程去执行，并且工作队列是执行在线程上下文中，因此工作执行过程中可以被创新调度、
抢占、睡眠。
*工作项* 是工作队列中的元素，是一个回调函数和多个回调函数输入参数的集合，有时也会
有额外的属性成员，总之通过一个结构体即可记录和描述一个工作项。

* 工作队列的特性
通过一个工作队列来执行一个工作相比于直接执行，会有以下特性：
- 异步，工作不是在本中断或线程中执行，而是交由其他线程执行。
- 延期，交由低优先级线程执行，执行前可能被抢占，也可能有其他工作排在前面执行，所以
  提交工作队列到工作真正被执行之间会延时不定长时间。
- 排队，FIFO模式先到先执行。也肯定会有多个优先级的工作队列，低优先级的工作队列要等
  高优先级执行完才能执行。但同一工作队列内部顺序一定。
- 缓存，队列能缓存多个项，需要异步执行就丢进去。但有上限，满之后，新的入队项会被丢
  弃，丢弃个数会被统计下来。

* 实现（共享工作队列和自定义工作队列）
1. 共享工作队列：将新创建的工作任务添加到Linux内核创建的全局工作队列system_wq中，
   无需自己创建工作队列；
2. 自定义工作队列：将新创建的工作任务添加到自己创建的工作队列中；

#+begin_src c
  flush_work(); // 堵塞工作队列，直到工作任务完成
  flush_delayed_work(); // 等待延时工作任务完成
  cancel_work_sync();   // 取消工作队列并等待它的完成
  cancel_delayed_work(); // 取消延时工作任务
  cancel_delayed_work_sync(); // 取消延时工作任务并等待它完成
  create_workqueue();    // 对于多CPU系统，内核会在每个CPU上创建一个工作队列，使线程处理并行化
  create_singlethread_workqueue(); // 内核只在一个CPU上创建一个工作队列
  queue_work_on();在指定CPU上添加工作任务，queue_work()调用queue_work_on()在所有CPU上添加任务
#+end_src
