#+INCLUDE: "../../prefix.org"

#+TITLE: perf分时复用究竟是perf层实现还是kernel层实现，如何实现的 

* perf分时是在kernel层实现的证明
通过更改man perf_event_open中的例子，同时跑6个cycles事件，发现有
#+begin_src c
  #include <stdlib.h>
  #include <stdio.h>
  #include <unistd.h>
  #include <string.h>
  #include <sys/ioctl.h>
  #include <linux/perf_event.h>
  #include <asm/unistd.h>

  static long
  perf_event_open(struct perf_event_attr *hw_event, pid_t pid,
		  int cpu, int group_fd, unsigned long flags)
  {
	int ret;

	ret = syscall(__NR_perf_event_open, hw_event, pid, cpu,
		      group_fd, flags);
	return ret;
  }

  int
  main(int argc, char **argv)
  {
	struct perf_event_attr pe;
	long long count;
	int fd[10];
	const int num = 7;

	memset(&pe, 0, sizeof(struct perf_event_attr));
	pe.type = PERF_TYPE_HARDWARE;
	pe.size = sizeof(struct perf_event_attr);
	pe.config = PERF_COUNT_HW_INSTRUCTIONS;
	pe.disabled = 1;
	pe.exclude_kernel = 1;
	pe.exclude_hv = 1;
	pe.read_format |= PERF_FORMAT_TOTAL_TIME_ENABLED | PERF_FORMAT_TOTAL_TIME_RUNNING;

	for(int i=0; i<num; i++) {
	      fd[i] = perf_event_open(&pe, 0, -1, -1, 0);
	      if (fd[i] == -1) {
		    fprintf(stderr, "Error opening leader %llx\n", pe.config);
		    exit(EXIT_FAILURE);
	      }

	      ioctl(fd[i], PERF_EVENT_IOC_RESET, 0);
	      ioctl(fd[i], PERF_EVENT_IOC_ENABLE, 0);
	}
      

	for(int q=0; q<30000;q++)
	      printf("Measuring instruction count for this printf\n");


	struct read_format {
	      __u64 value;
	      __u64 time_enabled;
	      __u64 time_running;
	    
	}rf;
	for(int j=0; j<num; j++) {
	      ioctl(fd[j], PERF_EVENT_IOC_DISABLE, 0);
	      read(fd[j], &rf, sizeof(rf));

	      printf("Used %lld instructions  %lld total time  %lld enabled time\n", rf.value, rf.time_running, rf.time_enabled);

	      close(fd[j]);
	}
      
  }

#+end_src
上述代码跑的结果：
#+begin_src sh
Measuring instruction count for this printf
Measuring instruction count for this printf
Measuring instruction count for this printf
Measuring instruction count for this printf
Measuring instruction count for this printf
Measuring instruction count for this printf
Used 17627029 instructions  54345224 total time  63658298 enabled time
Used 17146052 instructions  52736348 total time  63700766 enabled time
Used 17990127 instructions  55644260 total time  63703022 enabled time
Used 15627260 instructions  48249592 total time  63704786 enabled time
Used 15259268 instructions  47919268 total time  63706056 enabled time
Used 9195625 instructions  30719774 total time  63706212 enabled time
Used 8960377 instructions  28858462 total time  63704204 enabled time
~ $ gcc ./perf_case.c && ./a.out
#+end_src
也知道，这里的enable事件，是相对于上层的enable，是事件注册下去的总时间，running事件才是真正在pmu硬件上运行的事件；
* kernel层实现
分为 事件注入列表 和 事件安排调度