#+INCLUDE: "../../prefix.org"

#+TITLE: python 学习                                 

容器序列：list, tuple, collections.deque可以存放不同类型的数据(因为存放的都是对象引用)
扁平序列：str, bytes, bytearray, memoryview, array.array, 只能容纳一种类型(存放值，更紧凑，但只能存放字符、字节和数值这种基础类型)

可变序列：list, bytearray, array.array, collections.deque, memoryview
不可变序：tuple, str, bytes

* 列表推导和生成器表达式

1. 列表推导的作用只有一个，生成列表。
2. 如果想生成其他类型的序列，生成器表达式最适用。
3. 生成器表达式背后遵守迭代器协议，可以逐个产出元素，而不是先建立一个完整的列表，然后再把
   这个列表传递给某个构造函数里。相当于list(list())
#+begin_src python :results output
  colors = ['black', 'white']
  sizes = ['S', 'M', 'L']
  for tshirt in ('%s%s'%(c, s) for c in colors for s in sizes):
      print(tshirt)

  print('%s%s'%(c, s) for c in colors for s in sizes) # 生成器表达式
  print(['%s%s'%(c, s) for c in colors for s in sizes]) # 列表推导
#+end_src

#+RESULTS:
: blackS
: blackM
: blackL
: whiteS
: whiteM
: whiteL
: <generator object <genexpr> at 0x7f8396ed0ac0>
: ['blackS', 'blackM', 'blackL', 'whiteS', 'whiteM', 'whiteL']

4. 也就是说，只要不是列表list，都应该适用生成器表达式
   
* 元组不仅仅是不可变的列表
元组除了可以用作不可变的列表，还可以用于没有字段名的记录。
#+begin_src python :results output
  lax_coordinates = (33.9425, -118.408)
  city, year, pop, chg, area = ('Tokyo', 2003, 32450, 0.66, 8014)
  traveler_ids = [('USA', '31195855'), ('BRA', 'CE342567'), ('ESP', 'XDA205856')]

  for passport in sorted(traveler_ids):
      print('%s/%s'%passport)

  for country, _ in traveler_ids:
      print(country)
#+end_src

#+RESULTS:
: BRA/CE342567
: ESP/XDA205856
: USA/31195855
: USA
: BRA
: ESP

元组拆包：
拆包方式1：
city, year, pop, chg, area = ('Tokyo', 2003, 32450, 0.66, 8014)

拆包方式2：
for country, _ in traveler_ids:

1. 唯一拆包硬性要求，被可迭代对象中的元素数量必须要跟接收这些元素的元组的空档数一致。
2. 除非用*来忽略多余元素。
3. 最好辨认元组拆包的形式：平行赋值：
   #+begin_src python :results output
     lax_coordinates = (33.9425, -118.408)
     latitude, longitude = lax_coordinates # 元组拆包
     print(latitude)
   #+end_src

   #+RESULTS:
   : 33.9425
4. 不使用中间变量来交换也是用元组方式实现：
   a, b = b, a
5. 还可以用*运算符把一个可迭代对象拆开：
   #+begin_src python :results output
     print(divmod(20, 8))
     t = (20, 8)
     print(divmod(*t))
     quotient, remainder = divmod(*t)
     print((quotient, remainder))
   #+end_src

   #+RESULTS:
   : (2, 4)
   : (2, 4)
   : (2, 4)
6. 元组拆包实现函数多个返回值：
   #+begin_src python :results output
     # os.path.split = split(p)
     #  Split a pathname.  Returns tuple "(head, tail)" where "tail" is
     #  everything after the final slash.  Either part may be empty.
     import os
     _, filename = os.path.split('/home/yjl00405/.ssh/idrsa.pub')
     print(filename)
     print(_)
   #+end_src

   #+RESULTS:
   : idrsa.pub
   : /home/yjl00405/.ssh
7. 如果是国际化软件，_可能不是一个理想占位符，因为他是gettext.gettext函数的别名。
   其他情况仍是一个好的占位符。
8. 用 * 来处理：
   #+begin_src python :results output
     a, b, *reset = range(5)
     print((a, b, reset))
     a, *reset, b = range(5)
     print((a, b, reset))
     *reset, a, b = range(5)
     print((a, b, reset))
     a, b, *reset = range(3)
     print((a, b, reset))
     a, b, *reset = range(2)
     print((a, b, reset))
   #+end_src

   #+RESULTS:
   : (0, 1, [2, 3, 4])
   : (0, 4, [1, 2, 3])
   : (3, 4, [0, 1, 2])
   : (0, 1, [2])
   : (0, 1, [])
9. 嵌套元组拆包
   #+begin_src python :results output
     metro_areas = [
	 ('Tokyo', 'JP', 36.234, (35.345, 123.345)),
	 ('Tokyo2', 'JP2', 3.234, (3.345, 12.345)),
     ]

     fmt = '{:15} | {:9.4f} | {:9.4f}'
     for name, cc, pop, (latitude, longitude) in metro_areas:
	 print(fmt.format(name, latitude, longitude))
   #+end_src

   #+RESULTS:
   : Tokyo           |   35.3450 |  123.3450
   : Tokyo2          |    3.3450 |   12.3450
10. 元组缺少一个给记录中字段命名的功能，namedtuple函数的出现可以帮我们解决这个问题：
    collections.namedtuple是一个工厂函数，它可以用来构建一个带字段名的元组和一个有名字的类，
    这个带名字的类对调试程序有很大的帮助。
    #+begin_src python :results output
      from collections import namedtuple
      # 类名， 类中各字段名
      City = namedtuple('City', 'name country population coordinates')
      tokyo = City('Tokyo', 'JP', 36.345, (35.456, 123,345))
      print(tokyo)
      # City(name='Tokyo', country='JP', population=36.345, coordinates=(35.456, 123, 345))

      print(tokyo.population)
      print(tokyo[0])

      print(City._fields)

      LatLong = namedtuple('LatLong', 'lat long')
      delhi_data = ('Delhi NCR', 'IN', 21.934, LatLong(28.34523, 77.20234))
      delhi = City._make(delhi_data)
      print(delhi._asdict())
      # {'name': 'Delhi NCR', 'country': 'IN', 'population': 21.934, 'coordinates': LatLong(lat=28.34523, long=77.20234)}
      
      print(delhi._asdict().items())
      # dict_items([('name', 'Delhi NCR'), ('country', 'IN'), ('population', 21.934), ('coordinates', LatLong(lat=28.34523, long=77.20234))])

      for key, value in delhi._asdict().items():
	  print(key+':', value)
    #+end_src

    #+RESULTS:
    #+begin_example
    City(name='Tokyo', country='JP', population=36.345, coordinates=(35.456, 123, 345))
    36.345
    Tokyo
    ('name', 'country', 'population', 'coordinates')
    {'name': 'Delhi NCR', 'country': 'IN', 'population': 21.934, 'coordinates': LatLong(lat=28.34523, long=77.20234)}
    dict_items([('name', 'Delhi NCR'), ('country', 'IN'), ('population', 21.934), ('coordinates', LatLong(lat=28.34523, long=77.20234))])
    name: Delhi NCR
    country: IN
    population: 21.934
    coordinates: LatLong(lat=28.34523, long=77.20234)
    #+end_example
11. _fields属性是一个包含这个类所有字段名的元组
12. _make()通过接收一个可迭代对象来生成这个类的一个实例，作用和City(*delhi_data)一样
13. _asdict()把具名元组以collections.OrderedDict的形式返回，我们可以利用它来把元组里的
    信息友好呈现出来。

* 强大的切片以及其高级用法
1. list, str, tuple, bytes, bytearray等序列类型都支持切片操作。
2. 切片和区间会忽略最后一个元素，符合Python，C和其他语言以0作为起始下标的传统。
   #+begin_src python :results output
     s = 'bicycle'
     print(s[::3])
     print(s[::1])
     print(s[::-1]) # 相当于reverse操作
   #+end_src

   #+RESULTS:
   : bye
   : bicycle
   : elcycib
3. a:b:c这种用法只能作为索引或者下标用在[]中来返回一个切片对象：slice(a, b, c)
4. 对seq[start:stop:step]进行求值时，Python会调用seq.__getitem__(slice(start, stop, step))。
5. 切片应用：
   #+begin_src python :results output
     invoice = """
     0.....6.................................40...........52...55.........
     1909  Pimoroni PiBrella                 $17.50       3    $52.50
     1489  6mm Tactile Switch x20            $4.95        2    $9.90
     1510  Panavise Jr.-PV-201               $28.00       1    $28.00 """
     SKU = slice(0, 6)
     DESCRIPTION = slice(6, 40)
     UNIT_PRICE = slice(40, 52)
     QUANTIY = slice(52, 55)
     ITEM_TOTAL = slice(55, None)
     line_items = invoice.split('\n')[2:]

     for item in line_items:
	 print(item[UNIT_PRICE], item[DESCRIPTION])
   #+end_src

   #+RESULTS:
   : slice(40, 52, None)
   : $17.50       Pimoroni PiBrella                 
   : slice(40, 52, None)
   : $4.95        6mm Tactile Switch x20            
   : slice(40, 52, None)
   : $28.00       Panavise Jr.-PV-201

给切片赋值：
#+begin_src python :results output
  print(range(10))
  print(list(range(10)))
  # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

  l = list(range(10))
  l[2:5] = [20, 30]
  print(l)
  # [0, 1, 20, 30, 5, 6, 7, 8, 9]

  del l[5:7]
  print(l)
  # [0, 1, 20, 30, 5, 8, 9]

  l[3::2] = [11, 22]
  print(l)
  # [0, 1, 20, 11, 5, 22, 9]

  # l[2:5] = 100
  # Traceback (most recent call last):
  # File "<stdin>", line 18, in <module>
  # TypeError: can only assign an iterable

  l[2:5] = [100]
  print(l)
  # [0, 1, 100, 22, 9]
#+end_src

#+RESULTS:
: range(0, 10)
: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
: [0, 1, 20, 30, 5, 6, 7, 8, 9]
: [0, 1, 20, 30, 5, 8, 9]
: [0, 1, 20, 11, 5, 22, 9]
: [0, 1, 100, 22, 9]
如果赋值对象，也就是左值是一个切片，那么赋值语句右边必须是个可迭代对象，
即便只有一个值，也要转换成可迭代对象。

* 对序列使用 + 和 *
#+begin_src python :results output
  l = list(range(3))
  print(l)
  # [0, 1, 2]

  print(l * 3)
  # [0, 1, 2, 0, 1, 2, 0, 1, 2]

  print(5 * 'abcde')
  # abcdeabcdeabcdeabcdeabcde
#+end_src

#+RESULTS:
: [0, 1, 2]
: [0, 1, 2, 0, 1, 2, 0, 1, 2]
: abcdeabcdeabcdeabcdeabcde
1. 注意容器序列中的引用
#+begin_src python :results output
  board = [['_'] * 3 for i in range(3)]
  print(board)
  # [['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']]

  board[1][2] = 'X'
  print(board)
  # [['_', '_', '_'], ['_', '_', 'X'], ['_', '_', '_']]
#+end_src

#+RESULTS:
: [['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']]
: [['_', '_', '_'], ['_', '_', 'X'], ['_', '_', '_']]

#+begin_src python :results output
  weird_board = [['_'] * 3] * 3
  print(weird_board)
  # [['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']]

  weird_board[1][2] = 'O'
  print(weird_board)
  # [['_', '_', 'O'], ['_', '_', 'O'], ['_', '_', 'O']]
#+end_src

#+RESULTS:
: [['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']]
: [['_', '_', 'O'], ['_', '_', 'O'], ['_', '_', 'O']]

#+begin_src python :results output
  print(type('_'))
  # <class 'str'>

  board = ['_']
  print(id(board[0]))
  print([board * 3])
  print([id(idx) for idx in board * 3])
  tmp = board * 3
  print(tmp)
  print([id(idx) for idx in tmp])
  tmp[0] = 'Q'
  print(tmp)
  print([id(idx) for idx in tmp])

  board1 = [['_'] * 3] * 3
  board2 = [['_'] * 3 for i in range(3)]
  print(board1)
  print([id(idx) for idx in board1])
  print(board2)
  print([id(idx) for idx in board2])

  row = ['_'] * 3
  board3 = []
  for i in range(3):
      board3.append(row)
  print(board3)
  print([id(idx) for idx in board3])

  board4 = []
  for i in range(3):
      row = ['_'] * 3
      board4.append(row)
  print(board4)
  print([id(idx) for idx in board4])
#+end_src

#+RESULTS:
#+begin_example
<class 'str'>
140229860342256
[['_', '_', '_']]
[140229860342256, 140229860342256, 140229860342256]
['_', '_', '_']
[140229860342256, 140229860342256, 140229860342256]
['Q', '_', '_']
[140229858517616, 140229860342256, 140229860342256]
[['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']]
[140229858519488, 140229858519488, 140229858519488]
[['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']]
[140229858519232, 140229858519040, 140229858518976]
[['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']]
[140229858518848, 140229858518848, 140229858518848]
[['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']]
[140229858518592, 140229858518464, 140229858518400]
#+end_example

* 序列增量赋值 += 和 *=
1. 增量赋值运算符+= 和 *=取决于他们的第一个操作对象。
2. += 背后的特殊方法是__iadd__，用于‘就地加法’，如果没有实现，就会调用__add__。
3. 对可变序列来说，a += b中a会就地改变，和调用a.extend(b)一样。
4. 如果a没有实现__iadd__，那么a+=b == a=a+b，也就是会生成新的对象给a。
5. 变量名会不会关联到新的对象，完全取决于这个类型有没有实现__iadd__这个方法。
6. 可变序列一半都实现了__iadd__方法。不可变序列根本不支持此类操作。
7. *= 对应的是 __imul__。
#+begin_src python :results output
  l = list(range(3))
  print(id(l))
  l *= 2
  print(id(l))

  t = tuple(range(3))
  print(id(t))
  t *= 2
  print(id(t))
#+end_src   

#+RESULTS:
: 140667941147328
: 140667941147328
: 140667941299904
: 140667941716224
