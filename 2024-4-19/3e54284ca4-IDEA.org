#+INCLUDE: "../../prefix.org"

#+TITLE: switcher logic                            

1. 本地通过http协议发送(https之后再看)：
   请求路径/switcher/
   local_ip=192.168.xxx.xxx
   status=online/offline
   version=1
服务器需要返回ACK,并且这个route需要1min一次。
服务器记录request_ip, local_ip,,status三个数据。
2. 用户向服务器发起http请求，服务器进行功能展示，通过重定向功能，经由用户向esp32发送命令，
   再由esp32操作之后重定向会服务器，将操作结果返回。

#+begin_src python :indent 4
def remote_server_closed():
    pass
def http_get(url):
    import socket
    _, _, host, path = url.split('/', 3)
    addr = socket.getaddrinfo(host, 80)[0][-1]
    s = socket.socket()
    try:
        s.connect(addr)
    except OSError:
        print('connects remote server failed.')
        remote_server_closed()
        return
    s.send(bytes('GET /%s HTTP/1.0\r\nHost: %s\r\n\r\n' % (path, host), 'utf8'))
    while True:
	data = s.recv(100)
        if data:
	    print(str(data, 'utf8'), end='')
	else:
	    break
    s.close()

def get_local_ip():
    'caller needs to ensure network is fine.'
    import network
    return network.WLAN(network.STA_IF).ifconfig()[0]

def isConnected():
    import network
    return network.WLAN(network.STA_IF).isconnected()

def local_wifi_no_connected():
    print('local_wifi_no_connected')

def callback(t):
    if not isConnected():
        return 0
    local_ip = get_local_ip()
    status = 'online'
    version = '1'
    http_get(f'http://124.222.214.132/esp32c3?{local_ip=}&{status=}&{version=}')

from machine import Timer
timer = Timer(0,
	      mode=Timer.PERIODIC,
	      period=1000*5,
	      callback=callback)

#+end_src

#+begin_src python :indent 4
import socket, network

CONTENT = b"""\
HTTP/1.0 302 Found

Location: http://124.222.214.132/
"""

def main(micropython_optimize=False):
    s = socket.socket()

    # Binding to all interfaces - server will be accessible to other hosts!
    ai = socket.getaddrinfo("0.0.0.0", 80)
    print("Bind address info:", ai)
    addr = ai[0][-1]

    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    s.bind(addr)
    s.listen(5)
    print("Listening, connect your browser to http://%s:80/" %
          network.WLAN(network.STA_IF).ifconfig()[0])

    while True:
        res = s.accept()
        client_sock = res[0]
        client_addr = res[1]
        print("Client address:", client_addr)
        print("Client socket:", client_sock)

        if not micropython_optimize:
            # To read line-oriented protocol (like HTTP) from a socket (and
            # avoid short read problem), it must be wrapped in a stream (aka
            # file-like) object. That's how you do it in CPython:
            client_stream = client_sock.makefile("rwb")
        else:
            # .. but MicroPython socket objects support stream interface
            # directly, so calling .makefile() method is not required. If
            # you develop application which will run only on MicroPython,
            # especially on a resource-constrained embedded device, you
            # may take this shortcut to save resources.
            client_stream = client_sock

        print("Request:")
        req = client_stream.readline()
        print(req)
        while True:
            h = client_stream.readline()
            if h == b"" or h == b"\r\n":
                break
            print(h)
        client_stream.write(CONTENT)

        client_stream.close()
        if not micropython_optimize:
            client_sock.close()
        print()


main()
#+end_src