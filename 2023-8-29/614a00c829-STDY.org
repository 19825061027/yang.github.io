#+INCLUDE: "../../prefix.org"

#+TITLE: 学习rootfs相关内容并理解多种方式加载的区别    

* ramfs, rootfs and initramfs
** What is ramfs?
1. Ramfs is a very simple filesystem that exports Linux's disk caching mechanisms(the page cache and dentry cache) as a dynamically resizable RAM-based filesystem.
2. 正常情况下，Linux会将所有文件都缓存在内存中，这也就是Linux Kernel的一项缓存机制；
3. 从backing store(usually the block device the filesystem is mounted on)读出来的数据页，会缓存到内存中，以防止再次需要；但也同时会标记为clean(freeable)，以便在内存不需要，VM可以释放这块空间做其他事情；
4. 同样道理，写到标记有clean页的数据，也会立刻写回到backing store，以便VM可以随时重分配这块内存；一个相似的机制(the dentry cache)极大地加快了对目录的访问；
5. 而对于ramfs而言，是没有backing store的；但正常的写操作，仍会正常，只是没有地方作为backing store进行写回；这也就意味着，可以简单地通过将page标记为非clean实现；
6. 拿来实现ramfs的code量是很少的，因为所有的工作是在Linux caching基础上实现的；因此，menuconfig中是没有可选的移除选项用来移除ramfs的，因为这样节省下的空间几乎可以忽略不计；
** ramfs and ramdisk:
1. The older "ram disk" mechanism created a synthetic block device out of an area of RAM and used it as backing store for a filesystem. This block device was of fixed size, so the filesystem mounted on it was of fixed size.Using a ram disk also required unnecessarily copying memory from the fake block device into the page cache (ache copying changes back out), as well as creating and destroying dentries. Plus it needed a filesystem driver (such as ext2) to format and interpret this data.
2. Compared to ramfs, this waste memory(and memory bus bandwidth), creates unnecessary work for the CPU, and pollutes the CPU caches. (There are tricks to avoid this copying by playing with the page tables, but they're unpleasantly complicated and turn out to be about as expensive as the copying anyway.). More to the point, all the wortk ramfs is doing has to happen _anyway_, since all file access goes through the page and dentry caches. The RAM disk is simply unnecessary; ramfs is internally much simpler.
3. Another reason ramdisks are semi-obsolete is that the introduction of loopback devices offered a more flexible and convenient way to create synthetic block devices, now from files instead of rom chunks of memory. See losetup for details.
** ramfs and tmpfs:
1. ramfs的一个缺点就是数据只能写入，VM无法释放，因为VM认为数据应该写回backing store，所以不会主动将非clean数据进行释放，但ramfs又没有backing store；因此，只有root用户才允许对ramfs挂载进行访问；
2. ramfs的衍生是tmpfs，用来增加大小限制，和将数据写进交换空间(swap space)的能力；普通用户也有权限访问tmpfs挂载；
** What is rootfs?
1. rootfs是ramfs(or tmpfs, if that's enabled)的实现；rootfs是无法卸载的，和无法杀死init process具有相同的原因；
2. 大多数系统会将rootfs进行覆盖并忽视它；并且一个空ramfs的实现占的空间是很少的；
3. 如果CONFIG_TMPFS使能了，rootfs默认使用tmpfs代替ramfs；想要强制使用ramfs，可以在kernel命令行使用rootfstype=ramfs；
** What is initramfs?
1. 自kernel2.6，kernel包含了一个gzip压缩的cpio格式的archive，用来在kernel启动的时候将其解压进rootfs；提取之后，kernel检查rootfs是否包含文件init，如果有，就将其作为PID1进程进行执行；并且，这个进程有责任执行OS启动的其他义务，包括定位和挂载正式的根设备；
2. 提取完embedded cpio archive之后，如果找不到init程序，kernel将会调用老的代码来定位并挂载一个根分区，接着执行/sbin/init或其他变种；
3. 这些在以下几个方面区别于old initrd：
   1. old initrd总是是一个单独的文件；而initramfs是链接进kernel镜像的；(linux/usr就是用来在building期间生成archive的)；
   2. 老的initrd文件是一个gzipped压缩的文件系统镜像(这个镜像往往有如ext2这种文件系统格式的，因此，还需要将ext2驱动编译进kernel)，而新的initramfs archive是一个gzipped压缩过的cpio文档(比tar包还简单)；kernel的cpio提取代码不仅小，还会标记为__init类型的文本和数据段，这种标记会在启动过程中释放这个代码和数据；
   3. 由老式initrd(/initrd)启动的程序会做一些设置，并返回到内核，而initramfs的init程序则不会返回到kernel；如果/init需要转交控制权，则它可以用一个新的设备覆盖挂载根 / ，并执行另一个初始化进程，相关内容查看下面的switch_root工具；
   4. 当切换到另一个根设备时，initrd将会pivot_root并卸载ramdisk；但initramfs对应的是rootfs，可以既不pivot_root rootfs，也不卸载rootfs；代替删除rootfs里的一切来释放空间(find -xdev / -exec rm '{}' ';')，而是用新的根来overmount rootfs(cd /newmount; mount --move . /; chroot .)；并将stdin/stdout/stderr附着于新的/dev/console上，并exec新的init程序；
      - 上述删除和overmount的过程是一个非常棘手的过程，因此，klibc包提供了助手程序(utils/run_init.c)；许多其他包如busybox将其命名为switch_root；
** Populating initramfs:
1. 自2.6以来，kernel构建进程总是创建一个gzip压缩过的cpio格式的initramfs文档；并将其链接进最终kernel镜像；默认情况下，这个文档是空的(在x86上消耗134bytes)；
2. 配置选项CONFIG_INITRAMFS_SOURCE可以用来为initramfs文档指定一个源，之后将会自动将此文档放到最终二进制镜像中；此选项可以指向一个存在了的gzip压缩过的cpio文档，也可以是一个包含想要被归档文件的目录，或者一个指明下述内容的一个文本文件：
   #+begin_example
   dir /dev 755 0 0
   nod /dev/console 644 0 0 c 5 1
   nod /dev/loop0 644 0 0 b 7 0
   dir /bin 755 1000 1000
   slink /bin/sh busybox 777 0 0
   file /bin/busybox initramfs/busybox 755 0 0
   dir /proc 755 0 0
   dir /sys 755 0 0
   dir /mnt 755 0 0
   file /init initramfs/init.sh 755 0 0 
   #+end_example

3. 配置文件的一个优势就是根访问不再设置权限，也不再需要在新档中创建设备节点；但上述例子中需要在linux根目录下提供目录initramfs以及这两个指定的文件；
4. kernel不依赖外部的cpio工具，如果指定的是一个目录，而非文件，则kernel的构建架构将会根据那个目录创建那个配置文件(usr/Makefile 调用 usr/gen_initramfs.sh)，并继续根据配置文件打包该目录(通过将其供给usr/gen_init_cpio)；kernel的构建时cpio创建代码完全自供，以及启动时解压提取代码也是自供；
5. 如果想直接提供给kernel一个打包好的gzip压缩过的cpio archive，那才需要外部cpio工具；
6. 下面命令用来提取一个cpio文档：
   #+begin_src sh
     cpio -i -d -H newc -F initramfs_data.cpio --no-absolute-filenames
   #+end_src

7. Note：cpio的man手册提供了一些不可取的建议；手册说"A typical way to generate the list of filenames is with the find command; you should give find the -depth option to minimize problems with permissions on directories that are unwritable or not searchable."不要通过这种方式创建initramfs.cpio.gz镜像，那将不会工作；

** External initramfs images:
1. 如果kernel使能了initrd，一个外部的cpio.gz文档同样可以传给2.6版本的kernel用来代替initrd；这种情况下，kernel将会自动检测类型并在尝试运行/init之前，将外部cpio文档提取进rootfs；
2. 也就是传统传递initrd的方式，可以传递initramfs gzipped cpio archive；kernel会自动判断是哪种archive；

* kernel中关于内建rootfs的组织,即通过CONFIG_INITRAMFS_SOURCE方式指定
1. 可以通过CONFIG_INITRAMFS_SOURCE指定一个打包好的gzip压缩过的cpio文档、或一个文件配合一个initramfs/目录、或一个目录；
2. 第二种，由kernel内建的cpio工具(不知道是否kernel会进行gzip压缩)usr/gen_init_cpio进行压缩，只需要将CONFIG_INITRAMFS_SOURCE指定的文件作为参数传递；
3. 第三种，由usr/gen_initramfs.sh工具根据目录生成对应的cpio_list文件，如/tmp/cpiolist.XXXXXX,其中内容如下：
   #+begin_example sh
   #####################
   # tmprootfs
   # Last modified: 1693217731.9921122990

   dir /bin 755 1000 1000
   slink /bin/arch busybox 777 1000 1000
   slink /bin/ash busybox 777 1000 1000
   slink /bin/base32 busybox 777 1000 1000
   slink /bin/base64 busybox 777 1000 1000
   file /bin/busybox tmprootfs/bin/busybox 755 1000 1000
   slink /bin/cat busybox 777 1000 1000
   slink /bin/chattr busybox 777 1000 1000
   slink /bin/chgrp busybox 777 1000 1000
   slink /bin/chmod busybox 777 1000 1000
   slink /bin/chown busybox 777 1000 1000
   slink /bin/conspy busybox 777 1000 1000
   slink /bin/cp busybox 777 1000 1000
   ......
   slink /bin/watch busybox 777 1000 1000
   slink /bin/zcat busybox 777 1000 1000
   dir /etc 755 1000 1000
   file /etc/fstab tmprootfs/etc/fstab 644 1000 1000
   dir /etc/init.d 755 1000 1000
   file /etc/init.d/rcS tmprootfs/etc/init.d/rcS 755 1000 1000
   file /etc/inittab tmprootfs/etc/inittab 644 1000 1000
   file /etc/profile tmprootfs/etc/profile 644 1000 1000
   slink /linuxrc bin/busybox 777 1000 1000
   dir /sbin 755 1000 1000
   slink /sbin/acpid ../bin/busybox 777 1000 1000
   slink /sbin/adjtimex ../bin/busybox 777 1000 1000
   slink /sbin/arp ../bin/busybox 777 1000 1000
   slink /sbin/blkid ../bin/busybox 777 1000 1000
   slink /sbin/blockdev ../bin/busybox 777 1000 1000
   slink /sbin/bootchartd ../bin/busybox 777 1000 1000
   slink /sbin/depmod ../bin/busybox 777 1000 1000
   slink /sbin/devmem ../bin/busybox 777 1000 1000
   slink /sbin/fbsplash ../bin/busybox 777 1000 1000
   .......
   slink /sbin/zcip ../bin/busybox 777 1000 1000
   dir /tmp 755 1000 1000
   dir /usr 755 1000 1000
   dir /usr/bin 755 1000 1000
   slink /usr/bin/[ ../../bin/busybox 777 1000 1000
   slink /usr/bin/[[ ../../bin/busybox 777 1000 1000
   slink /usr/bin/ascii ../../bin/busybox 777 1000 1000
   slink /usr/bin/awk ../../bin/busybox 777 1000 1000
   slink /usr/bin/basename ../../bin/busybox 777 1000 1000
   slink /usr/bin/bc ../../bin/busybox 777 1000 1000
   slink /usr/bin/beep ../../bin/busybox 777 1000 1000
   slink /usr/bin/blkdiscard ../../bin/busybox 777 1000 1000
   slink /usr/bin/bunzip2 ../../bin/busybox 777 1000 1000
   slink /usr/bin/bzcat ../../bin/busybox 777 1000 1000
   .......
   slink /usr/bin/yes ../../bin/busybox 777 1000 1000
   dir /usr/sbin 755 1000 1000
   slink /usr/sbin/add-shell ../../bin/busybox 777 1000 1000
   slink /usr/sbin/addgroup ../../bin/busybox 777 1000 1000
   slink /usr/sbin/adduser ../../bin/busybox 777 1000 1000
   slink /usr/sbin/arping ../../bin/busybox 777 1000 1000
   slink /usr/sbin/brctl ../../bin/busybox 777 1000 1000
   slink /usr/sbin/chat ../../bin/busybox 777 1000 1000
   slink /usr/sbin/chpasswd ../../bin/busybox 777 1000 1000
   slink /usr/sbin/chroot ../../bin/busybox 777 1000 1000
   .......
   slink /usr/sbin/udhcpd ../../bin/busybox 777 1000 1000
   
   #+end_example

4. Makefile逻辑顺序：
   1. 调用gen_initramfs.sh生成cpio文档
       #+begin_src makefile
		 cmd_initfs := sh usr/gen_initramfs.sh -o usr/initramfs_data.cpio -l usr/.initramfs_data.cpio.d -u 0 -g 0 $(ramfs-input)
	 usr/initramfs_data.cpio : usr/gen_initramfs.sh usr/gen_init_cpio $(deps_initramfs) FORCE		$(call if_changed,initfs)
       #+end_src
       其中，deps_initramfs如果是第二种，就会是specfile 加上initramfs/目录下的全部文件，如果是第三种，就应该是指定目录下的所有文件；ramfs-input如果是第二第三种，就是CONFIG_INITRAMFS_SOURCE指定的对象；

   2. 根据cpio压缩文档为gzip文档
      #+begin_src makefile
	initramfs_inc_data: initramfs_data.cpio
		$(call if_changed,$(compress-y))
      #+end_src

   3. 根据压缩过后的文档，生成kernel链接的目标对象文件
      #+begin_src makefile
	obj-$(CONFIG_BLK_DEV_INITRD) := initramfs_data.o	
	initramfs_data.o: initramfs_inc_data
      #+end_src
      CONFIG_BLK_DEV_INITRD的说明：Initial RAM filesystem and RAM disk (initramfs/initrd) support

   4. 而initramfs_data.o由initramfs_data.S编译而成：
      #+begin_src asm
		.section .init.ramfs,"a"
	__irf_start:
		.incbin "usr/initramfs_inc_data"
	__irf_end:
		.section .init.ramfs.info,"a"
		.globl __initramfs_size
	__initramfs_size:
		.quad __irf_end - __irf_start
      #+end_src
      上述内容主要就是将二进制文件usr/initramfs_inc_data作为initramfs_data.o的一个名为.init.ramfs的一个section，生成elf，最后合进vmlinux

   5. 将section .init.ramfs 合进vmlinux

* 尝试CONFIG_INITRAMFS_SOURCE采用文件
** 简单版本
#+begin_example sh
# structure
/specfile
/initramfs/busybox
/initramfs/init.sh
#+end_example

#+begin_example sh
# specfile
dir /dev 755 0 0
nod /dev/console 644 0 0 c 5 1
nod /dev/loop0 644 0 0 b 7 0
dir /bin 755 1000 1000
slink /bin/sh busybox 777 0 0
file /bin/busybox initramfs/busybox 755 0 0
dir /proc 755 0 0
dir /sys 755 0 0
dir /root 755 0 0
dir /mnt 755 0 0
file /init initramfs/init.sh 755 0 0 
#+end_example

#+begin_src sh
  #!/bin/sh
  export PATH=/sbin:/bin
  echo hello world!
  exec /bin/sh # couldn't write as exec /bin/busybox here.
#+end_src

结果：报错 /bin/sh: can't access tty; job control turned off
百度答案：需要文件/etc/inittab
见<2023-08-31 Thu>日更新
