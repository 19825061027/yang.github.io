#+INCLUDE: "../../prefix.org"

#+TITLE: linux physical_memory.rst                 

1. sizeof(struct page) = 64
2. pnf_to_page and page_to_pnf采用vmemmap使用虚拟映射内存映射来优化
3. vmemmap是struct page *类型，指向一个虚拟连续的struct page对象阵列。
4. pfn是vmemmap数组索引，可以直接获得目标page
5. vmemmap范围分配：
#+begin_src python
def sparse_init():
    def sparse_init_nid():
	def __populate_section_memmap():
            def vmemmap_populate():
                pass
#+end_src
#+begin_src c
static void __init sparse_init_nid(int nid, unsigned long pnum_begin,
				   unsigned long pnum_end,
				   unsigned long map_count)
{
	struct mem_section_usage *usage;
	unsigned long pnum;
	struct page *map;

	usage = sparse_early_usemaps_alloc_pgdat_section(NODE_DATA(nid),
			mem_section_usage_size() * map_count);

	sparse_buffer_init(map_count * section_map_size(), nid);
	// 开始遍历，每次2^17个page，遍历8次: 8 * 2^17 * 4k = 2^32 = 4G
	for_each_present_section_nr(pnum_begin, pnum) {
		unsigned long pfn = section_nr_to_pfn(pnum);

		if (pnum >= pnum_end)
			break;
		// 获取从vmemmap开始的虚拟地址以及对应存放struct page的物理地址
		map = __populate_section_memmap(pfn, PAGES_PER_SECTION,
				nid, NULL, NULL);

		check_usemap_section_nr(nid, usage);
		sparse_init_one_section(__nr_to_section(pnum), pnum, map, usage,
				SECTION_IS_EARLY);
		usage = (void *) usage + mem_section_usage_size();
	}
	sparse_buffer_fini();
	return;
}
#+end_src
