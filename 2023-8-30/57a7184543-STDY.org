#+INCLUDE: "../../prefix.org"

#+TITLE: epapr 的生成及其初始运行                      

1. 假设 vmlinux 已生成；
2. 调用脚本wrapper: vmlinux --> zImage.epapr
   #+begin_src makefile
     # define CONFIG_EPAPR_BOOT in .config
     image-$(CONFIG_EPAPR_BOOT) += zImage.epapr	
     cmd_wrap := sh ./arch/powerpc/boot/wrapper -Z gz -c -o arch/powerpc/boot/zImage.epapr -p vmlinux

     $(addprefix $(obj)/, $(sort $(filter zImage.%, $(image-y)))): vmlinux $(wrapperbits) FORCE
	      $(call if_changed,wrap,$(subst $(obj)/zImage.,,$@))	
   #+end_src

3. wrapper脚本中行为：
   1. strip all redundant information:
      #+begin_src sh
	objcopy -S vmlinux ./vmlinux.strip.gz.$$
	strip_size = sizeof ./vmlinux.strip.gz.$$
      #+end_src

   2. compress the image.
      #+begin_src sh
	gzip -n -f -9 ./vmlinux.strip.gz.$$
	mv -f ./vmlinux.strip.gz.$$ ./vmlinux.strip.gz
      #+end_src

   3. Round the size to next higher MB limit
      #+begin_src sh
	link_address='0x20000000'
	round_size=$(((strip_size + 0xfffff) & 0xfff00000))
	round_size=0x$(printf "%x" $round_size)
	link_addr=$(printf "%d" $link_address)
	version="5.18.0-ga4ffd4e50ea8-dirty"
      #+end_src

   4. Make gzipped vmlinux.strip as a section of a elf file.
      #+begin_src sh
	objcopy arch/powerpc/boot/empty.o ./zImage.XXXXXX.o --add-section=.kernel:vmlinux.strip=./vmlinux.strip.gz --set-section-flags=.kernel:vmlinux.strip=contents,alloc,load,readonly,data
      #+end_src

   5. Link everything.
      #+begin_src sh
	ld -m elf64lppc -T arch/powerpc/boot/zImage.lds \
	   -Ttext 0x20000000 -pie --no-dynamic-linker -z notext \
	   -o arch/powerpc/boot/zImage.epapr \
	   arch/powerpc/boot/pseries-head.o \
	   arch/powerpc/boot/epapr.o \
	   arch/powerpc/boot/epapr-wrapper.o \
	   arch/powerpc/boot/empty.o \
	   arch/powerpc/boot/wrapper.a
	# -pie: Produce a dynamically linked position independent executable on targets that support it.
	# --no-dynamic-linker
	# -z keyword: -z is passed directly on to the linker along with the keyword.
      #+end_src

   6. post-processing needed for some platforms.
      #+begin_src sh
	arch/powerpc/boot/addnote arch/powerpc/boot/zImage.epapr
      #+end_src

4. 启动
   -Ttext 0x20000000指定了入口位置：
   #+begin_src sh
     readelf -hs zImage.epapr
     ELF Header:
     ...
     Entry point address:               0x20000000
     ...
     Section Headers:
     [Nr] Name              Type             Address           Offset
     Size              EntSize          Flags  Link  Info  Align
     [ 0]                   NULL             0000000000000000  00000000
     0000000000000000  0000000000000000           0     0     0
     [ 1] .text             PROGBITS         0000000020000000  00010000
     000000000000d4b0  0000000000000000  AX       0     0     32
     [ 2] .data             PROGBITS         000000002000e000  0001e000
     0000000000001a90  0000000000000000  WA       0     0     8
     [ 3] __builtin_cmdline PROGBITS         000000002000fa90  0001fa90
     0000000000000800  0000000000000000  WA       0     0     8
     [ 4] .dynsym           DYNSYM           0000000020010290  00020290
     0000000000000048  0000000000000018   A       5     3     8
     [ 5] .dynstr           STRTAB           00000000200102d8  000202d8
     0000000000000001  0000000000000000   A       0     0     1
     [ 6] .dynamic          DYNAMIC          00000000200102e0  000202e0
     0000000000000130  0000000000000010  WA       5     0     8
     [ 7] .got              PROGBITS         0000000020010500  00020500
     0000000000000018  0000000000000008  WA       0     0     256
     [ 8] .hash             HASH             0000000020010518  00020518
     0000000000000018  0000000000000004   A       4     0     8
     [ 9] .gnu.hash         GNU_HASH         0000000020010530  00020530
     000000000000001c  0000000000000000   A       4     0     8
     [10] .eh_frame         PROGBITS         000000002001054c  0002054c
     000000000000236c  0000000000000000   A       0     0     4
     [11] .rela.dyn         RELA             00000000200128b8  000228b8
     0000000000000288  0000000000000018   A       4     0     8
     [12] .kernel:vmlinux.s PROGBITS         0000000020013000  00023000
     00000000006c9e03  0000000000000000   A       0     0     1
     [13] .bss              NOBITS           00000000206dd000  006ece03
     0000000000001698  0000000000000000  WA       0     0     8
     [14] .debug_info       PROGBITS         0000000000000000  006ece03
     000000000001117f  0000000000000000           0     0     1
     [15] .debug_abbrev     PROGBITS         0000000000000000  006fdf82
     0000000000002cf4  0000000000000000           0     0     1
     [16] .debug_loc        PROGBITS         0000000000000000  00700c76
     000000000001b004  0000000000000000           0     0     1
     [17] .debug_aranges    PROGBITS         0000000000000000  0071bc7a
     0000000000000330  0000000000000000           0     0     1
     [18] .debug_line       PROGBITS         0000000000000000  0071bfaa
     0000000000009af6  0000000000000000           0     0     1
     [19] .debug_str        PROGBITS         0000000000000000  00725aa0
     0000000000001dc0  0000000000000001  MS       0     0     1
     [20] .comment          PROGBITS         0000000000000000  00727860
     000000000000002c  0000000000000001  MS       0     0     1
     [21] .debug_ranges     PROGBITS         0000000000000000  0072788c
     00000000000022b0  0000000000000000           0     0     1
     [22] .symtab           SYMTAB           0000000000000000  00729b40
     0000000000001b00  0000000000000018          23   141     8
     [23] .strtab           STRTAB           0000000000000000  0072b640
     0000000000000e80  0000000000000000           0     0     1
     [24] .shstrtab         STRTAB           0000000000000000  0072c4c0
     00000000000000f2  0000000000000000           0     0     1
     Key to Flags:
     W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
     L (link order), O (extra OS processing required), G (group), T (TLS),
     C (compressed), x (unknown), o (OS specific), E (exclude),
     p (processor specific)
   #+end_src
   #+begin_src sh
     objdump -d zImage.epapr
     arch/powerpc/boot/zImage.epapr:     file format elf64-powerpcle

     Disassembly of section .text:

     0000000020000000 <_start>:
     20000000:	48 00 00 08 	tdi     0,r0,72
     20000004:	2c 00 00 48 	b       20000030 <_start+0x30>
     20000008:	7d 60 00 a6 	.long 0xa600607d
     2000000c:	69 6b 00 01 	.long 0x1006b69
     20000010:	39 40 00 00 	.long 0x4039
     20000014:	7d 41 01 64 	oris    r1,r0,16765
     20000018:	42 9f 00 05 	.long 0x5009f42
     2000001c:	7d 48 02 a6 	lhzu    r16,18557(r2)
     20000020:	39 4a 00 14 	.long 0x14004a39
     20000024:	7d 5a 03 a6 	lhzu    r16,23165(r3)
     20000028:	7d 7b 03 a6 	lhzu    r16,31613(r3)
     2000002c:	4c 00 00 24 	dozi    r0,r0,76
     20000030:	c8 02 00 48 	b       200002f8 <_zimage_start_lib>
     ...
     00000000200002f8 <_zimage_start_lib>:
     200002f8:	05 00 00 48 	bl      200002fc <p_base>

     00000000200002fc <p_base>:
     200002fc:	a6 02 48 7d 	mflr    r10
     20000300:	ec ff aa f8 	std     r5,-20(r10)
     ...
     200003f8:	81 fe ff 4b 	bl      20000278 <platform_init+0x8>
     200003fc:	ec 0d 00 48 	b       200011e8 <start+0x8>
   #+end_src

   1. 代码运行轨迹：
      pseries-head.S::0x20000000::_zimage_start ->
          crt0.S::_zimage_start_lib ->
	  epapr-wrapper.c::platform_init    
	  main.c::start
