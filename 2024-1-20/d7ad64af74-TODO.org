#+INCLUDE: "../../prefix.org"

#+TITLE: IRQ总结                                      

http://www.wowotech.net/linux_kenrel/irq-domain.html
从架构层到通用层，通用层的接口：int generic_handle_irq(unsigned int irq)
因此，架构层需要从硬件那里获取到hwirq，并对应到irq上。

在不同发展时期，这个对应过程也具有不同的处理方式：
最开始只有一个中断控制器时，可以irq == hwirq
再到多个中断控制器并联，需要hwirq + 代表中断控制器实例的irqchip标识寻找到唯一irq
并且当多个中断控制器串联时，就出现了专门管理hwieq --> irq的实例，irq_domain

#+begin_src c
  static LIST_HEAD(irq_domain_list); // 串联许多irq_domain

  // 负责管理hwirq --> irq的映射，架构层会通过irq_domain_list遍历获取映射
  struct irq_domain {
	  struct list_head		link;
	  const char			*name; // 中断域名
	  const struct irq_domain_ops	*ops;  // irq_domain的方法
	  unsigned int			flags;
	  unsigned int			mapcount; // 映射的中断数量
	  struct irq_domain		*root;    // 指向根域，用于串联阶层

	  /* Optional data */
	  struct fwnode_handle		*fwnode;
	  enum irq_domain_bus_token	bus_token;
	  struct irq_domain_chip_generic	*gc;
	  struct device			*dev;
	  struct device			*pm_dev;
  #ifdef	CONFIG_IRQ_DOMAIN_HIERARCHY
	  struct irq_domain		*parent;
  #endif
  #ifdef CONFIG_GENERIC_MSI_IRQ
	  const struct msi_parent_ops	*msi_parent_ops;
  #endif

	  /* reverse map data. The linear map gets appended to the irq_domain */
	  irq_hw_number_t			hwirq_max;
	  unsigned int			revmap_size;
	  struct radix_tree_root		revmap_tree;
	  struct irq_data __rcu		*revmap[] __counted_by(revmap_size);
  };

#+end_src
* OF-dts对interrupt-map/parent的解析
1. devicetree中实现了逻辑中断树，代表了hierarchy and routing of interrupts in the platform hardware.
2. 设备节点中的interrupt-parent对应了物理中的中断线，代表了source->controller的连接.
3. 如果节点没有interrupt-parent,则假设其parent是设备树中的parent.
4. controller称为域，一个域一个#interrupt-cells用来表述interrupts=<>;
5. 虽然gpiochip往往只有一个中断线输出，但因为其往往有多个中断输入，因此gpiochip也是一个中断域.
6. interrupt nexus定义了中断域之间的翻译表，由interrupt-map定义.
7. interrupt controller属性：interrupt-cells & interrupt-controller
8. interrupt nexus属性：interrupt-cells & interrupt-map & interrupt-map-mask
9. nexus是负责两个域之间的映射.

Interrupt Nexus Introduce:
#+begin_src dts
  axi@18000000 {
		compatible = "brcm,bus-axi";
		reg = <0x18000000 0x1000>;
		ranges = <0x00000000 0x18000000 0x00100000>;
		#address-cells = <1>;
		#size-cells = <1>;

		#interrupt-cells = <1>;
		interrupt-map-mask = <0x000fffff 0xffff>;
		interrupt-map =
                        <child_unit_address child_interrupt_specifier interrupt-parent
                        parent-unit-address parent-interrupt-specifier>,
			/* ChipCommon */
			<0x00000000 0 &gic GIC_SPI 85 IRQ_TYPE_LEVEL_HIGH>,
                    
			/* PCIe Controller 0 */
			<0x00012000 0 &gic GIC_SPI 126 IRQ_TYPE_LEVEL_HIGH>,
			<0x00012000 1 &gic GIC_SPI 127 IRQ_TYPE_LEVEL_HIGH>,
			<0x00012000 2 &gic GIC_SPI 128 IRQ_TYPE_LEVEL_HIGH>,
			<0x00012000 3 &gic GIC_SPI 129 IRQ_TYPE_LEVEL_HIGH>,
			<0x00012000 4 &gic GIC_SPI 130 IRQ_TYPE_LEVEL_HIGH>,
			<0x00012000 5 &gic GIC_SPI 131 IRQ_TYPE_LEVEL_HIGH>;

		chipcommon: chipcommon@0 {
			reg = <0x00000000 0x1000>;
			gpio-controller;
			#gpio-cells = <2>;
			interrupt-controller;
			#interrupt-cells = <2>;
		};
		pcie0: pcie@12000 {
			reg = <0x00012000 0x1000>;
			#address-cells = <3>;
			#size-cells = <2>;
		};
	};
#+end_src
<child_unit_address child_interrupt_specifier interrupt-parent
parent-unit-address parent-interrupt-specifier>:
child_unit_address: 被映射的子节点的单元地址, 32bit，个数由子节点所在总线的#address-cells属性决定。在这里也就是axi bus,所以个数为1.
child_interrupt_specifier: 被映射子节点的中断描述符。32bit，个数由nexus的#interrupt-cells决定，此处也是1.
interrupt_parent: 指向interrupt parent，也就是子域指向的父域.
parent_unit_address + parent_interrupt_specifier + parent_interrupt_specifier:
就是我们常写在中断源节点中的interrupts = <>;也就配合interrupt_parent，指明了映射目标所在的域以及具体的中断描述符。

child_unit_address + child_interrupt_secifier:
就是指明了被映射的源节点以及具体的源中断描述符
* 通用接口层