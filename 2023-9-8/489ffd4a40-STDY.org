#+INCLUDE: "../../prefix.org"

#+TITLE: 学习cpu_hotplug

* cpu_hotplug
1. 一个更加新颖的CPU-hotplug支持使用是在suspend resume support for SMP.

2. 命令行开关：
   - =="maxcpus=n"== 限制启动时cpus数量到n；假如有四个CPUs，使用maxcpus=2,启动时则只会启动两个cpu，启动后可再选择启动其他cpu；
   - =="nr_cpus=n"== 限制kernel支持的CPUs数量；被舍弃的cpu在启动之后也不可再使用；
   - =="additional_cpus=n"== 限制可热插拔的cpus数量："cpu_possible_mask = cpu_present_mask + additional_cpus"
   - =="possible_cpus=n"== 此选项设置"cpu_possible_mask"中的"possible_cpus"比特位；
   - =="cpu0_hotplug"== 允许关闭CPU0；

3. CPU maps：
   - =="cpu_possbile_mask"== 系统中可以使用的CPUs的位图；用来在启动时为CPU分配每cpu变量空间，这些变量不受CPUs的卸载与安装而收缩或生长；
   - =="cpu_online_mask"== 当前在线的CPUs位图；在"__cpu_up()"中设置，如果一个cpu可以被kernel进行调度并准备接收设备中断；"__cpu_disable()"可以将CPU在kernel视角进行下线，但要保证所有OS服务和中断迁移到其他CPU；
   - =="cpu_present_mask"== 当前系统中存在的CPU位图；他们中并非全部在线；当相关子系统进行物理热插拔时，通过事件hot-add/hot-remove处理此bitmap；比bitmap当前还没有固定规则，目前典型的时候是在boot阶段，当禁用热插拔时初始化topology;
   - 这三个位图不需要直接操作，大部分使用都是只需要读取就可以了；当设置每cpu资源时，总是使用 "cpu_possible_mask" 或 "for_each_possbile_cpu()" 来迭代；对于宏 "for_each_cpu()" 可以用来迭代一个自定义的CPU mask；代表CPUs位图时要使用 "cpumask_t" 而不是其他；

4. 使用CPU热插拔：
   - ==CONFIG_HOTPLUG_CPU== 使能此内核选项；
     #+begin_src sh
       ls -lh /sys/devices/system/cpu
     #+end_src
     #+RESULTS:
     | total      | 0 |      |      |      |     |    |       |                 |
     | drwxr-xr-x | 5 | root | root |    0 | Sep |  8 | 11:04 | cpu0            |
     | drwxr-xr-x | 5 | root | root |    0 | Sep |  8 | 11:04 | cpu1            |
     | drwxr-xr-x | 5 | root | root |    0 | Sep |  8 | 11:04 | cpu10           |
     | drwxr-xr-x | 5 | root | root |    0 | Sep |  8 | 11:04 | cpu11           |
     | drwxr-xr-x | 5 | root | root |    0 | Sep |  8 | 11:04 | cpu12           |
     | drwxr-xr-x | 5 | root | root |    0 | Sep |  8 | 11:04 | cpu13           |
     | drwxr-xr-x | 5 | root | root |    0 | Sep |  8 | 11:04 | cpu14           |
     | drwxr-xr-x | 5 | root | root |    0 | Sep |  8 | 11:04 | cpu15           |
     | drwxr-xr-x | 5 | root | root |    0 | Sep |  8 | 11:04 | cpu2            |
     | drwxr-xr-x | 5 | root | root |    0 | Sep |  8 | 11:04 | cpu3            |
     | drwxr-xr-x | 5 | root | root |    0 | Sep |  8 | 11:04 | cpu4            |
     | drwxr-xr-x | 5 | root | root |    0 | Sep |  8 | 11:04 | cpu5            |
     | drwxr-xr-x | 5 | root | root |    0 | Sep |  8 | 11:04 | cpu6            |
     | drwxr-xr-x | 5 | root | root |    0 | Sep |  8 | 11:04 | cpu7            |
     | drwxr-xr-x | 5 | root | root |    0 | Sep |  8 | 11:04 | cpu8            |
     | drwxr-xr-x | 5 | root | root |    0 | Sep |  8 | 11:04 | cpu9            |
     | drwxr-xr-x | 2 | root | root |    0 | Sep |  8 | 11:04 | cpufreq         |
     | drwxr-xr-x | 2 | root | root |    0 | Sep |  8 | 11:04 | cpuidle         |
     | drwxr-xr-x | 2 | root | root |    0 | Sep |  8 | 11:04 | hotplug         |
     | -r--r--r-- | 1 | root | root | 4.0K | Sep |  8 | 11:04 | isolated        |
     | -r--r--r-- | 1 | root | root | 4.0K | Sep |  8 | 11:04 | kernel_max      |
     | -r--r--r-- | 1 | root | root | 4.0K | Sep |  8 | 11:04 | modalias        |
     | -r--r--r-- | 1 | root | root | 4.0K | Sep |  8 | 11:04 | offline         |
     | -r--r--r-- | 1 | root | root | 4.0K | Sep |  8 | 11:04 | online          |
     | -r--r--r-- | 1 | root | root | 4.0K | Aug | 29 | 11:16 | possible        |
     | -r--r--r-- | 1 | root | root | 4.0K | Aug | 29 | 11:16 | present         |
     | drwxr-xr-x | 2 | root | root |    0 | Sep |  8 | 11:04 | smt             |
     | -rw-r--r-- | 1 | root | root | 4.0K | Sep |  8 | 11:04 | uevent          |
     | drwxr-xr-x | 2 | root | root |    0 | Sep |  8 | 11:04 | vulnerabilities |
     1. 文件 offline/online/possible/present 代表CPU mask；
     2. 每一个cpu文件夹包含一个online文件用来控制CPU的逻辑开关 (0/1)
     #+begin_src sh
       echo 0 > /sys/devices/system/cpu/cpu4/online
       smpboot: CPU 4 is now offline
     #+end_src
     1. CPU关机之后，就会从/proc/interrupts和/proc/cpuinfo中移除；
     2. CPU0总是特殊的，并且一般不支持热插拔；

** CPU 热插拔协调(The CPU hotplug coordination)
1. 卸载case：
   - 一旦CPU进行逻辑上的关机，就会调用注册进来的，在状态转换时进行调用的回调函数: CPUHP_ONLINE --> CPUHP_OFFLINE
     1. 如果由于一个suspend操作导致任务冻结，则 "cpuhp_tasks_frozen" 设置为 true；
     2. 所有进行从当前处理器迁移到其他处理器；新处理器从进程的cpuset，也就是进程想要在哪些处理器上运行，上进行选择；
     3. 当前处理器上的所有中断迁移到新处理器上；
     4. 迁移定时器事件；
     5. 所有服务迁移完成后，kernel调用一个架构指定的routine "__cpu_disable()" 来执行架构清理工作；

** CPU热插拔API(THe CPU hotplug API)
*** CPU hotplug state machine
1. CPU从CPUHP_OFFLINE到CPUHP_ONLINE，每个状态都有一个startup/teardown回调函数；
2. 当CPU上线时，各个状态的startup回调函数顺序调用，直到CPUHP_ONLINE；They can also be invoked when the callbacks of a state are set up or an instance is added to a multi-instance state. CPU下线也同理；
3. If a usage site requires only a callback in one direction of the hotplug operations (CPU online or CPU offline) then the other not-required callback can be set to NULL when the state is set up.

4. 有一个词状态空间state space，尝试理解它，它分为三个部分：
   1. The PREPARE section
      - 占据状态空间中：CPUHP_OFFLINE --> CPUHP_BRINGUP_CPU
      - 这个部分下的startup回调函数在CPU online操作之后，真正online之前；
      - 这个部分下的teardow回调函数在CPU offline操作之后，真正失效之前；
      - 这个部分下，这些回调函数都由一个控制CPU调用，因为目标CPU还没起来或已经下线；
      - startup回调允许失败，如果失败，则online终止；CPU会变成之前的状态，通常是CPUHP_OFFLINE.
      - teardown回调不允许失败；
   2. The STARTING section
      - CPUHP_BRINGUP_CPU + 1 --> CPUHP_AP_ONLINE
      - startup/teardown回调函数在目标CPU上运行，目标CPU中断禁止；回调函数不允许失败；
      - 回调函数用来为核心子系统做低级硬件初始化或关机；
   3. The ONLINE section
      - CPUHP_AP_ONLINE + 1 --> CPUHP_ONLINE
      - startup/teardown在目标CPU上调用运行；
      - 回调函数在per CPU hotplug thread上下文调用，这个thread是固定于每个可插拔CPU的；当前中断和抢占都在使能；
      - 回调允许失败，失败后操作终止，回归到原来状态；
*** CPU online/offline operations
一个成功的online操作如下：
#+begin_src rst
  [CPUHP_OFFLINE]
  [CPUHP_OFFLINE + 1]->startup()       -> success
  [CPUHP_OFFLINE + 2]->startup()       -> success
  [CPUHP_OFFLINE + 3]                  -> skipped because startup == NULL
  ...
  [CPUHP_BRINGUP_CPU]->startup()       -> success
  === End of PREPARE section
  [CPUHP_BRINGUP_CPU + 1]->startup()   -> success
  ...
  [CPUHP_AP_ONLINE]->startup()         -> success
  === End of STARTUP section
  [CPUHP_AP_ONLINE + 1]->startup()     -> success
  ...
  [CPUHP_ONLINE - 1]->startup()        -> success
  [CPUHP_ONLINE]
#+end_src

一个成功的offline操作如下：
#+begin_src rst
  [CPUHP_ONLINE]
  [CPUHP_ONLINE - 1]->teardown()       -> success
  ...
  [CPUHP_AP_ONLINE + 1]->teardown()    -> success
  === Start of STARTUP section
  [CPUHP_AP_ONLINE]->teardown()        -> success
  ...
  [CPUHP_BRINGUP_ONLINE - 1]->teardown()
  ...
  === Start of PREPARE section
  [CPUHP_BRINGUP_CPU]->teardown()
  [CPUHP_OFFLINE + 3]->teardown()
  [CPUHP_OFFLINE + 2]                  -> skipped because teardown == NULL
  [CPUHP_OFFLINE + 1]->teardown()
  [CPUHP_OFFLINE]
#+end_src
   
一个失败的online操作：
#+begin_src rst
  [CPUHP_OFFLINE]
  [CPUHP_OFFLINE + 1]->startup()       -> success
  [CPUHP_OFFLINE + 2]->startup()       -> success
  [CPUHP_OFFLINE + 3]                  -> skipped because startup == NULL
  ...
  [CPUHP_BRINGUP_CPU]->startup()       -> success
  === End of PREPARE section
  [CPUHP_BRINGUP_CPU + 1]->startup()   -> success
  ...
  [CPUHP_AP_ONLINE]->startup()         -> success
  === End of STARTUP section
  [CPUHP_AP_ONLINE + 1]->startup()     -> success
  ---
  [CPUHP_AP_ONLINE + N]->startup()     -> fail
  [CPUHP_AP_ONLINE + (N - 1)]->teardown()
  ...
  [CPUHP_AP_ONLINE + 1]->teardown()
  === Start of STARTUP section
  [CPUHP_AP_ONLINE]->teardown()
  ...
  [CPUHP_BRINGUP_ONLINE - 1]->teardown()
  ...
  === Start of PREPARE section
  [CPUHP_BRINGUP_CPU]->teardown()
  [CPUHP_OFFLINE + 3]->teardown()
  [CPUHP_OFFLINE + 2]                  -> skipped because teardown == NULL
  [CPUHP_OFFLINE + 1]->teardown()
  [CPUHP_OFFLINE]
#+end_src

一个失败的offline操作：
#+begin_src rst
  [CPUHP_ONLINE]
  [CPUHP_ONLINE - 1]->teardown()       -> success
  ...
  [CPUHP_ONLINE - N]->teardown()       -> fail
  [CPUHP_ONLINE - (N - 1)]->startup()
  ...
  [CPUHP_ONLINE - 1]->startup()
  [CPUHP_ONLINE]
#+end_src

重复失败的话，会停在最后失败的地方；
online过程失败 --> 尝试offline --> offline失败 --> 再次online --> 还是失败 --> endless loop
*** Allocating a state
两种方法：
静态分配
   - perf core(kernel core)的startup callback需要在perf driver(device driver)的startup callback之前调用；
   - During a CPU offline operation the driver teardown callbacks have to be invoked before the core teardown callback.
   - 静态分配在 "cpuhp_state" enum中的常量进行描述，可以在 include/linux/cpuhotplug.h中找到；
动态分配
   - 只有PREPARE & ONLINE sections提供有动态分配的范围；
*** Setup of a CPU hotplug state
热插拔核心提供以下接口：
- cpuhp_setup_state(state, name, startup, teardown)
- cpuhp_setup_state_nocalls(state, name, startup, teardown)
- cpuhp_setup_state_cpuslocked(state, name, startup, teardown)
- cpuhp_setup_state_nocalls_cpuslocked(state, name, startup, teardown)
有多个实例instances的驱动或子系统，每个实例都需要在CPU热插拔时进行调用，CPU 热插拔核心提供了多实例支持；与驱动程序特定的实力列表相比，其优势在于，与实例相关的函数完全针对CPU hotplug操作进行序列化，并在添加和删除时提供状态回调的自动调用；
- cpuhp_setup_state_multi(state, name, startup, teardown)
@state 参数可以时静态分配的状态，也可以是需要进行动态分配的标识CPUHP_PREPARE_DYN/CPUHP_ONLINE_DYN;
@name  用来给sysfs进行输出；明明约定："sybsys:mode", or "subsys/driver:mode"; 如 "perf:mode" or "perf/x86:mode"； 常见的mode有如下几个：
========= ===============================================================================
prepare   For states in the PREPARE section. 如果state是prepare section中的，则这样设置；
dead      For states in the PREPARE section which do not provide a startup callback;
starting  For states in the STARTING section;
dying     For states in the STARTING section which do not provide a startup callback;
online    For states in the ONLINE section;
offline   For states in the ONLINE section which do not provide a startup callback;
========= ===============================================================================
因为@name只用来给sysfs做说明，因此，如果有更合适的@name，也可以用来替换上面这些；
@name例子："perf/online", "perf/x86:prepare", "RCU/tree:dying", "sched/waitempty" 
@startup指向一个CPU online操作时，@state状态下的回调函数；必须要则置NULL；
@teardown同理；

这些函数在处理注册回调的方式有所不同：
- cpuhp_setup_state_nocalls(), cpuhp_setup_state_nocalls_cpuslocked() and cpuhp_setup_state_multi()只安装回调函数；
- cpuhp_setup_state() and cuphp_setup_state_cpuslocked() 安装并在所有在线且状态大于当前注册的@state的CPU上调用@startup；取决于state section，callback在PREPARE section时，在当前CPU上调用，ONLINE时，在每个online CPU上都调用(in the context of the CPU's hotplug thread)；
If a callback fails for CPU N then the teardown callback for CPU 0..N-1 is invoked to rollback the operation. The state setup fails, the callbacks for the state are not installed and in case of dynamic allocation the allocated state is freed.

The state setup and the callback invocations are serialized against CPU hotplug operations. If the setup function has to be called from a CPU hotplug read locked region, then the _cpuslocked() variants have to be used. These functions cannot be used from within CPU hotplug callbacks.

函数返回值：
===== ============================================================================
0     静态分配的状态设置成功
>0    动态分配的状态设置成功
      返回值就是分配的状态号；如果状态回调之后不得不需要移除，则需要保存此状态号；
<0    操作失败
===== ============================================================================
*** Removal of a CPU hotplug state
- cpuhp_remove_state(state)
- cpuhp_remove_state_nocalls(state)
- cpuhp_remove_state_nocalls_cpuslocked(state)
- cpuhp_remove_multi_state(state)

cpuhp_remove_state(state) 移除回调函数并在CPU状态大于此状态号的在线上CPUs调用teardown；

为了完成移除，teardown不能失败；
*** Multi-Instance state instance management
Once the multi-instance state is set up, instances can be added to the state:
- cpuhp_state_add_instance(state, node)
- cpuhp_state_add_instance_nocalls(state, node)

@state 可以是静态分配的状态号，也可以是cpuhp_setup_state_multi()动态分配的；
@node  一个指向hlist_node的指针，hlist_node是嵌在实例数据结构中的一个成员；
       这个指针通过node传递给multi-instance状态回调函数，可以通过它及container_of获取到具体实例的数据结构；

两个函数的不同：
cpuhp_state_add_instance_nocalls()只添加实例到multi-instance state's node list;
cpuhp_state_add_instance()不但只添加实例，也调用startup回调函数；再描述一遍，只有CPUs当前的状态比@state大，才会在CPUs上执行；并且，取决于状态所处的section，如果是PREPARE section,则只在当前CPU上调用，如果是ONLINE section，则在每个online CPU的热插拔线程上下文调用；

从状态的节点列表上移除实例：
- cpuhp_setup_remove_instance(state, node)
- cpuhp_setup_remove_instance_nocalls(state, node)
其他同理，不再描述；  

*** Examples
在STARTING section静态分配并设置startup/teardown函数，以便在online/offline操作时得到通知:
#+begin_src c
  ret = cpuhp_setup_state(CPUHP_SUBSYS_STARTING, "subsys:starting", subsys_cpu_starting, subsys_cpu_dying);
  if(ret < 0)
	return ret;
  ...;
  cpuhp_remove_state(CPUHP_SUBSYS_STARTING);
#+end_src

动态分配并只在offline操作时调用：
#+begin_src c
  state = cpuhp_setup_state(CPUHP_ONLINE_DYN, "subsys:offline", NULL, subsys_cpu_offline);
  if(state < 0)
	return state;
  ...;
  cpuhp_remove_state(state);
#+end_src

ONLINE section + callback on online operations + without invoking:
#+begin_src c
  state = cpuhp_setup_state_nocalls(CPUHP_ONLINE_DYN, "subsys:online", subsys_cpu_online, NULL);
  if(state < 0)
	return state;
  ...;
  cpuhp_remove_state_nocalls(state);
#+end_src

ONLINE section + callback on online/offline operations + multi-instances:
#+begin_src c
  state = cpuhp_setup_state_multi(CPUHP_ONLINE_DYN, "subsys:online", subsys_cpu_online, subsys_cpu_offline); // no callbacks
  if(state < 0)
	return state;
  ...;
  ret = cpuhp_setup_add_instance(state, &inst1->node); // callback
  if(ret)
	return ret;
  ...;
  ret = cpuhp_setup_add_instance(state, &inst2->node); // callback
  if(ret)
	return ret;
  ...;
  cpuhp_remove_instance(state, &inst1->node); // callback
  ...;
  cpuhp_remove_instance(state, &inst2->node); // callback
  ...;
  cpuhp_remove_multi_state(state);
#+end_src
*** Testing of hotplug states
验证一个自定义状态是否工作的一个方法是关闭一个核并重新打开，或者将核置到某个状态，如CPUHP_AP_ONLINE，然后返回到CPUHP_ONLINE; 后者可以模拟CPUHP_AP_ONLINE之后状态上回调函数的出错返回前一个状态的行为；

所有注册状态列举在 "/sys/devices/system/cpu/hotplug/states" 中;
 $ tail /sys/devices/system/cpu/hotplug/states
 138: mm/vmscan:online
 139: mm/vmstat:online
 140: lib/percpu_cnt:online
 141: acpi/cpu-drv:online
 142: base/cacheinfo:online
 143: virtio/net:online
 144: x86/mce:online
 145: printk:online
 168: sched:active
 169: online

将CPU4回滚到 140 lib/percpu_cnt:online然后返回online：
  $ cat /sys/devices/system/cpu/cpu4/hotplug/state
  169
  $ echo 140 > /sys/devices/system/cpu/cpu4/hotplug/target
  $ cat /sys/devices/system/cpu/cpu4/hotplug/state
  140
此时，140状态的teardown也调用了；然后，返回：
  $ echo 169 > /sys/devices/system/cpu/cpu4/hotplug/target
  $ cat /sys/devices/system/cpu/cpu4/hotplug/state
  169

当使能跟踪事件时，可看到单个步骤：
#+begin_example
  #  TASK-PID   CPU#    TIMESTAMP  FUNCTION
  #     | |       |        |         |
      bash-394  [001]  22.976: cpuhp_enter: cpu: 0004 target: 140 step: 169 (cpuhp_kick_ap_work)
   cpuhp/4-31   [004]  22.977: cpuhp_enter: cpu: 0004 target: 140 step: 168 (sched_cpu_deactivate)
   cpuhp/4-31   [004]  22.990: cpuhp_exit:  cpu: 0004  state: 168 step: 168 ret: 0
   cpuhp/4-31   [004]  22.991: cpuhp_enter: cpu: 0004 target: 140 step: 144 (mce_cpu_pre_down)
   cpuhp/4-31   [004]  22.992: cpuhp_exit:  cpu: 0004  state: 144 step: 144 ret: 0
   cpuhp/4-31   [004]  22.993: cpuhp_multi_enter: cpu: 0004 target: 140 step: 143 (virtnet_cpu_down_prep)
   cpuhp/4-31   [004]  22.994: cpuhp_exit:  cpu: 0004  state: 143 step: 143 ret: 0
   cpuhp/4-31   [004]  22.995: cpuhp_enter: cpu: 0004 target: 140 step: 142 (cacheinfo_cpu_pre_down)
   cpuhp/4-31   [004]  22.996: cpuhp_exit:  cpu: 0004  state: 142 step: 142 ret: 0
      bash-394  [001]  22.997: cpuhp_exit:  cpu: 0004  state: 140 step: 169 ret: 0
      bash-394  [005]  95.540: cpuhp_enter: cpu: 0004 target: 169 step: 140 (cpuhp_kick_ap_work)
   cpuhp/4-31   [004]  95.541: cpuhp_enter: cpu: 0004 target: 169 step: 141 (acpi_soft_cpu_online)
   cpuhp/4-31   [004]  95.542: cpuhp_exit:  cpu: 0004  state: 141 step: 141 ret: 0
   cpuhp/4-31   [004]  95.543: cpuhp_enter: cpu: 0004 target: 169 step: 142 (cacheinfo_cpu_online)
   cpuhp/4-31   [004]  95.544: cpuhp_exit:  cpu: 0004  state: 142 step: 142 ret: 0
   cpuhp/4-31   [004]  95.545: cpuhp_multi_enter: cpu: 0004 target: 169 step: 143 (virtnet_cpu_online)
   cpuhp/4-31   [004]  95.546: cpuhp_exit:  cpu: 0004  state: 143 step: 143 ret: 0
   cpuhp/4-31   [004]  95.547: cpuhp_enter: cpu: 0004 target: 169 step: 144 (mce_cpu_online)
   cpuhp/4-31   [004]  95.548: cpuhp_exit:  cpu: 0004  state: 144 step: 144 ret: 0
   cpuhp/4-31   [004]  95.549: cpuhp_enter: cpu: 0004 target: 169 step: 145 (console_cpu_notify)
   cpuhp/4-31   [004]  95.550: cpuhp_exit:  cpu: 0004  state: 145 step: 145 ret: 0
   cpuhp/4-31   [004]  95.551: cpuhp_enter: cpu: 0004 target: 169 step: 168 (sched_cpu_activate)
   cpuhp/4-31   [004]  95.552: cpuhp_exit:  cpu: 0004  state: 168 step: 168 ret: 0
      bash-394  [005]  95.553: cpuhp_exit:  cpu: 0004  state: 169 step: 140 ret: 0

#+end_example
As it be seen, CPU4 went down until timestamp 22.996 and then back up until 95.552. All invoked callbacks including their return codes are visible in the trace.
** Architecture's requirements
Following functions and configurations are required:
- ==CONFIG_HOTPLUG_CPU== This entry needs to be enabled in Kconfig
- ==__cpu_up()== Arch interface to bring up a CPU
- ==__cpu_disable()== Arch interface to shutdown a CPU, no more interrupts can be handled by the kernel after the routine returns. This includes the shutdown of the timer.
- ==__cpu_die()== This actually supposed to ensure death of the CPU. Actually look at some example code in other arch that implement CPU hotplug. The processor is taken down from the "idle()" loop for that specific architecure. "__cpu_die()" typically waits for some per_cpu state to be set, to ensure the processor dead rontine is called to be sure positively.
** User Space Notification
CPU成功online/offline后，udev事件发送(样例)：
SUBSYSTEM=="cpu", DRIVERS=="processor", DEVPATH=="/devices/system/cpu/*", RUN+="the_hotplug_receiver.sh"
将会收到所有事件，一个脚本可以进一步处理：
#+begin_src sh
  #!/bin/sh

  if [ "${ACTION}" = "offline" ]
  then
      echo "CPU ${DEVPATH##*/} offline"

  elif [ "${ACTION}" = "online" ]
  then
      echo "CPU ${DEVPATH##*/} online"

  fi
#+end_src
