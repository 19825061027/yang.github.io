#+INCLUDE: "../../prefix.org"

#+TITLE: DTB格式                                      

IEEE1275 Open Firmware没有定义DTB格式；在大多数符合OpenFirmware的平台，设备树通过调用固件方法，遍历树结构提取；
DTB格式使用一个单一，线性，无指针的数据格式编码设备树；
由一个小头+三个可变大小的sections组成：
|--------------------------|
| struct fdt_header        |
| (free space)             |
| memory reservation block |
| (free space)             |
| structure block          |
| (free space)             |
| strings block            |
| (free space)             |
|--------------------------|
free space可能存在，也可能不存在，存在的原因可以是对齐；

Versioning
header中的域会给出当前DTB的版本，此文档只描述V17版格式；
* Header
#+begin_src c
  struct fdt_header {
	// 0xd00dfeed(big-endian)
	uint32_t magic;
	// sizeof(header + memory reservation block + structure block + strings block + free space gaps)
	uint32_t totalsize;
	// offset in bytes of the structure block from the beginning of the header
	uint32_t off_dt_struct;
	// offset of the strings block
	uint32_t off_dt_strings;
	// offset of the memory resveration
	uint32_t off_mem_rsvmap;
	// Version of the dts. Current document is 17.
	uint32_t version;
	// Lowest version of the dts with which the version used is backwards compatible. This should be 16.
	// 17 is backwards compatible with 16, but not ealier version.
	uint32_t last_comp_version;
	// physical ID of the system's boot CPU.
	uint32_t boot_cpuid_phys;
	// length in bytes of the strings block section of the devicetree blob.
	uint32_t size_dt_strings;
	// length in bytes of the struture block section of the devicetree blob.
	uint32_t size_dt_struct;
  };
#+end_src

* Memory Reservation Block
目的：讲述了保留块是存放内存保留区列表的，以及内存保留区的一些实现和限制

给client program(如OS)提供保留物理内存(不能拿来当作通用内存进行分配)的列表；可以用来保护重要数据，放置被client program重写；
例子：有IOMMU的系统，由DTSpec启动程序初始化的TCE(translation control entry)表，需要使用这种方法保护；
例子：启动程序为client program提供的运行时服务(代码和数据)，需要采用这种方式保护；（OpenFirmware平台的RTAS）；

client program不应该访问保留区内的内存，除非启动程序显式指明可以访问；

启动程序提供的保留区间可以，但也不需要，包含设备树本身；因为client program需要保证在使用设备树之前，不会重写设备树中的内容，
无论设备树是否放到保留地址；

Any accesses to reserved memory by or caused by the boot program must be done as not Caching Inhibited and Memory Coherence Required
(i.e., WIMG=0bx01x). and addtionally for Book Ⅲ-S implementations as not Write Through Required(i.e., WIMG=0b001x). Further,
if the VLE storage attribute is supported, all accesses to reserved memory must be done as VLE=0.

This requirement is necessary because the client program is permitted to map memory with storage attributes specified as not Write
Through Required, not Caching Inhibited, and Memory Coherence Required(i.e., WIMG=0b001x), and VLE=0 where supported.

client program可能会使用包含保留内存的large virtual pages.然而，client program不会修改保留内存，因此，boot program对保留需区域的访问
是Write Through Required的。

格式：介绍了保留区的格式
#+begin_src c
  struct fdt_reserve_entry {
	uint64_t address;
	uint64_t size;
  }
#+end_src

内存保护块和UEFI
As with the /reserved-memory node, when booting via [UEFI] entries in the Memory Reservation Block must alos be listed in the system
memory map obtained via the GetMemoryMap() to protect against allocations by UEFI applications. The memory reservation block entries
should be listed with type EfiReservedMemoryType.

* Structure Block
描述了设备树本身的结构和内容；由一系列带有数据的tokens组成；
structure block由一系列pieces组成，每一个由一个token开始，也就是一个大端的32-bit整数；
一些token之后是额外的数据；
五个token类型：
- FDT_BEGIN_NODE(0x00000001)
  标志一个node的开始；之后是额外数据，node的unitname；name字符串的存储是null-terminal类型，并且name应该包括单元地址；
  nodename之后是一些用来填充对齐的0x0；
  下一个token，需要是除FDT_END之外的任何的token；
- FDT_END_NODE(0x00000002)
  标志node的结束；后面不会跟随额外数据，因此，后面会立刻是下一个除了FDT_PROP之外的token；
- FDT_PROP(0x00000003)
  标志一个属性的开始；后跟随额外数据描述属性；额外数据首先由属性长，和属性名组成：
  #+begin_src c
    struct {
	  uint32_t len;
	  uint32_t nameoff;
    };
  #+end_src  
  len指示属性的值的大小，单位字节；可以是0，表明是空属性；
  nameoff指示的偏移量是相对于strings block，这里面存储了属性名，以null-terminal方式存储；
  这个结构之后，就是真正的属性值了，大小就是len；
  属性值后，是用来进行对齐的padding bytes；
  下一个token是除FDT_END之外的任何token；
- FDT_NOP(x000000004)
  此会被解析设备树的程序忽略；
  没有额外数据；
  树中的属性或节点定义可以使用FDT_NOP重写，来将其移出树；
  也就是说，想要覆盖一个属性，可以将其用多个FDT_NOP填充覆盖，知道下一个有效token；
- FDT_END(0x00000009)
  标志structure block的结束；
  只能有一个；且只能是最后一个；
  没有额外数据；
  此token之后，是下一个size_dt_struct域指明的structure block开始；

Tree Structure
设备树结构表现为一个线性树：每一个节点开始于FDT_BEGIN_NODE token，结束于FDT_END_NODE token；
node的属性和子节点存在于FDT_END_NODE之前；
子节点的FDT_BEGIN_NODE/FDT_END_NODE嵌于其中；
structure block由根节点组成，之后是FDT_END标志其结束；

每一个节点由以下组件构成：
- (optionally)any number of FDT_NOP tokens
- FDT_BEGIN_NODE token
  - The node's name as a null-terminal string
  - [zeroed padding bytes to align to a 4-byte boundary]
- For each property of the node:
  - (optionally)any number of FDT_NOP tokens
  - FDT_PROP token
    * property information
    * [zeroed padding bytes to align to a 4-byte boundary]
- Representations of all child nodes in this format
- (optionally)any number of FDT_NOP tokens
- FDT_END_NODE token
为了代码处理方便，一个节点的属性应该在子节点之前；当然，属性和节点交叉配置并无大碍，只是为了代码处理流程简单，推介在前；  

* Strings Block
包含树种使用的所有属性名字符；
以null结尾，简单拼接；
没有对齐限制；