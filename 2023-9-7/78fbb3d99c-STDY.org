#+INCLUDE: "../../prefix.org"

#+TITLE: 学习kbuild

* KBuild
** Overview
1. Makefiles有五部分组成：
   | Makefile              | 顶层Makefile                           |
   | .config               | 内核配置文件                           |
   | arch/$(ARCH)/Makefile | 架构配置文件                           |
   | scripts/Makefile.*    | 普通规则等，对所有kbuild Makefiles生效 |
   | kbuild Makefiles      | 大约500多个                            |

2. 顶层Makefile的责任是构建两个主要产物：vmlinux(the resident kernel image) & modules(any module files)
3. 顶层Makefile会include arch/$(ARCH)/Makefile
4. kbuild Makefile采用.config中的信息来构建其中指定的文件列表或目标模组；
5. scripts/Makefile.*包含所有定义和规则等；
** kbuild files
*** obj-y
1. kbuild files 的首选配置文件名是 Makefile，但Kbuild也可用;并且同时存在时，Kbuild具有更好优先级；
2. 定义声明是kbuild files中重要部分；可以定义要构建的文件，特殊编译选项，递归子目录；
3. obj-y += foo.o 会将foo.c或foo.S编译成foo.o并链接进vmlinux
4. obj-m += foo.o 会编译foo.ko
5. Kbuild编译所有$(obj-y)文件；然后调用"$(AR) rcSTP" 将这些文件合并进built-in.a文件；
6. built-in.a是一个没有符号表的薄文档；
7. built-in.a通过脚本scripts/link-mvlinux.sh链接进vmlinux；
8. obj-y中文件顺序很重要，可重复，第一个会被链接进built-in.a，其他忽略；
9. 链接文件顺序很重要，因为某些函数(module_init() / initcall)会在启动时按顺序进行调用；
*** obj-m
1. obj-m普通情况，只有一个源文件：obj-m += isdn_bsdcomp.o
2. 含有多个源文件：
   #+begin_src Makefile
     obj-$(CONFIG_ISDN_I4L) += idsn.o
     isdn-y := isdn_net_lib.o isdn_v110.o isdn_common.o
   #+end_src
3. 模块名最终会是isdn.o；kbuild会编译$(isdn-y)中的文件，然后运行"$(LD) -r"生成isdn.o；
4. 模块可选源文件：
   #+begin_src makefile
     #fs/ext2/Makefile
     obj-$(CONFIG_EXT2_FS) += ext2.o
     ext2-y := balloc.o dir.o file.o ialloc.o inode.o ioctl.o \
     namei.o super.o symlink.o
     ext2-$(CONFIG_EXT2_FS_XATTR) += xattr.o xattr_user.o \
     xattr_trusted.o
   #+end_src
*** lib-y
#+begin_src makefile
  #fs/Makefile
  obj-$(CONFIG_EXT2_FS) += ext2/		
#+end_src
1. obj-y += ext2/ 将ext2构建进built-in.a并连接进vmlinux；
2. obj-m += ext2/ 将ext2构建成module；如果ext2/Makefile中含有obj-y，则视为bug；
*** Compilation flags: ccflags-y/asflags-y/ldflags-y/subdir-ccflags-y/subdir-asflags-y/ccflags-remove-y/asflags-remove-y/CFLAGS_$@/AFLAGS_$@
1. 分别传递给cc, as, ld;
2. EXTRA_CFLAGS/EXTRA_AFLAGS/EXTRA_LDFLAGS支持但过时；
   #+begin_src makefile
     # drivers/acpi/acpica/Makefile
     ccflags-y			:= -Os -D_LINUX -DBUILDING_ACPICA
     ccflags-$(CONFIG_ACPI_DEBUG)	+= -DACPI_DEBUG_OUTPUT

     #arch/sparc/kernel/Makefile
     asflags-y := -ansi

     #arch/cris/boot/compressed/Makefile
     ldflags-y += -T $(srctree)/$(src)/decompress_$(arch-y).lds
   #+end_src
3. 顶层KBUILD_CFLAGS作用于整个项目；
4. subdir-ccflags-y/subdir-asflags-y: 对当前和子目录均有效；subdir-*在命令中的会放在non-sudbid-*之前；
5. ccflags-remove-y/asflags-remove-y: 移除特殊编译选项；
6. CFLAGS_$@/AFLAGS_$@: 只应用于当前kbuild makefile；可以具体到单个源文件；
   #+begin_src makefile
     # drivers/scsi/Makefile
     CFLAGS_aha152x.o =   -DAHA152X_STAT -DAUTOCONF
     CFLAGS_gdth.o    = # -DDEBUG_GDTH=2 -D__SERIAL__ -D__COM2__ \
     -DGDTH_STATISTICS
   #+end_src
7. CFLAGS_$@比ccflags-remove-y有更高的优先级；可以重新添加被其删除的编译选项；
*** Special Rules
1. $(src) 是指向Makefile位置的相对目录变量；
2. $(obj) 是指向目标产物的位置；
   #+begin_src makefile
     #drivers/scsi/Makefile
     # 生成文件 drivers/scsi//53c8xx_d.h	
     $(obj)/53c8xx_d.h: $(src)/53c7,8xx.scr $(src)/script_asm.pl
     $(CPP) -DCHIP=810 - < $< | ... $(src)/script_asm.pl
   #+end_src
3. 即便src和obj相同，也得在prerequisite中使用src，target中使用obj；
4. kecho输出内容到标准输出；
   #+begin_src makefile
     #arch/blackfin/boot/Makefile
     $(obj)/vmImage: $(obj)/vmlinux.gz
     $(call if_changed,uimage)
     @$(kecho) 'Kernel: $@ is ready'
   #+end_src
*** Script invocation
1. 提供了$(CONFIG_SHELL) $(AWK) $(PERL) $(PYTHON) $(PYTHON3)来调用对应的脚本；
#+begin_src makefile
  #Makefile
  cmd_depmod = $(CONFIG_SHELL) $(srctree)/scripts/depmod.sh $(DEPMOD) \
  $(KERNELRELEASE)	  
#+end_src
** Kbuild clean infrastructure
1. "make clean" 删除文件targets listed in $(hostprogs), $(always-y), $(always-m), $(always-), $(extra-y), $(extra-) and $(targets);
2. 还包括文件：files matching the patterns "*.[oas]", "*.ko", plus some additional files generated by kbuild
3. 还可以通过$(clean-files)指定附加删除文件：
   #+begin_src makefile
     #lib/Makefile
     clean-files := crc32table.h	     
   #+end_src
4. $(no-clean-files)可避免某些文件被删除；
** Architecture Makefiles
kbuild执行时的步骤：
1. 配置内核，产生文件.config
2. 在include/linux/version.h中产生内核版本
3. 更新所有arch/$(ARCH)/Makefile中指定的其他prerequisites；
4. 递归init-* core-* drivers--* net-* libs-*中所列的目录并构建所有目标；
   上述值在arch/$(ARCH)/Makefile中被展开；
5. 链接所有对象文件并产生vmlinux；
   最前面链接的对象在head-y中，在arch/$(ARCH)/Makefile中赋值；
6. 架构专有部门做一些必要的延迟处理，并构建最终的bootimage：
   - 包括building boot records
   - 准备initrd镜像或其他类似内容
