#+INCLUDE: "../../prefix.org"

#+TITLE: pdev->id                                     

从devicetree过来的，基本上都是 pdev->id = PLATFORM_DEVID_NONE;
#+begin_src c
  // drivers/of/device.c
  int of_device_add(struct platform_device *ofdev)
  {
	  BUG_ON(ofdev->dev.of_node == NULL);

	  /* name and id have to be set so that the platform bus doesn't get
	   ,* confused on matching */
	  ofdev->name = dev_name(&ofdev->dev);
	  ofdev->id = PLATFORM_DEVID_NONE;

	  /*
	   ,* If this device has not binding numa node in devicetree, that is
	   ,* of_node_to_nid returns NUMA_NO_NODE. device_add will assume that this
	   ,* device is on the same node as the parent.
	   ,*/
	  set_dev_node(&ofdev->dev, of_node_to_nid(ofdev->dev.of_node));

	  return device_add(&ofdev->dev);
  }


  // drivers/of/platform.c
  struct platform_device *of_device_alloc(struct device_node *np,
					  const char *bus_id,
					  struct device *parent)
  {
	  dev = platform_device_alloc("", PLATFORM_DEVID_NONE);
	  if (!dev)
		  return NULL;
	  ...;
  }



  // drivers/base/platform.c
  int platform_device_add(struct platform_device *pdev)
  {
	  u32 i;
	  int ret;

	  if (!pdev)
		  return -EINVAL;

	  if (!pdev->dev.parent)
		  pdev->dev.parent = &platform_bus;

	  pdev->dev.bus = &platform_bus_type;

	  switch (pdev->id) {
	  default:
		  dev_set_name(&pdev->dev, "%s.%d", pdev->name,  pdev->id);
		  break;
	  case PLATFORM_DEVID_NONE:
		  dev_set_name(&pdev->dev, "%s", pdev->name);
		  break;
	  case PLATFORM_DEVID_AUTO:
		  /*
		   ,* Automatically allocated device ID. We mark it as such so
		   ,* that we remember it must be freed, and we append a suffix
		   ,* to avoid namespace collision with explicit IDs.
		   ,*/
		  ret = ida_alloc(&platform_devid_ida, GFP_KERNEL);
		  if (ret < 0)
			  goto err_out;
		  pdev->id = ret;
		  pdev->id_auto = true;
		  dev_set_name(&pdev->dev, "%s.%d.auto", pdev->name, pdev->id);
		  break;
	  }
  }
#+end_src
因此，在写驱动时，这个pdev->id基本上都是-1。
可从of_alias获取索引，或自定义设备树节点属性。
