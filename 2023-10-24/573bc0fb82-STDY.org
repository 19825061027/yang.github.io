#+INCLUDE: "../../prefix.org"

#+TITLE: 前一个DEBUG总结，关于库函数底层               

1. malloc/calloc底层都是_sbrk，这个函数简单的实现就是从堆的起始地址开始，要多少分出去多少，从不管分过的区域；
#+begin_src c
  void *_sbrk(intptr_t increment)
  {
	if (increment == 0) {
	      return (void *)arch_mm_ctx.heap_break;
	} else {
	      uintptr_t heap_old = arch_mm_ctx.heap_break;
	      uintptr_t heap_new = arch_mm_ctx.heap_break + increment;

	      if (heap_new > ((uintptr_t)&__stackheap_end__)) {
		    errno = ENOMEM;

		    return (void *)-1;
	      } else {
		    arch_mm_ctx.heap_break = heap_new;

		    return (void *)heap_old;
	      }
	}
  }
#+end_src
2. _start中做的事情，和具体硬件实现有关，M7的SP设置就由约定放置，初始库里面的init.array和final.array就没有啥用，还有_exit，在main退出后执行，也没有啥用；
3. 因此，M7的启动只需要将BSS初始化为0，和进行data段这种需要由FLASH搬运到SRAM的操作；
4. 启动库和C库有着明显的区分；以后都不要C库了，只是用C库；
5. 但C库，参照armv8-A的实现，需要实现如下函数(其实armv7-m里面没有实现也可以直接用库里面的实现)：
#+begin_src c   
  #include <stdarg.h>
  #include <stdint.h>
  #include <stdio.h>
  #include <string.h>

  void *memset(void *s, int c, size_t count)
  {
	char *xs = s;
	while (count--)
	      ,*xs++ = (char)c;
	return s;
  }

  void *memcpy(void *dst, const void *src, size_t n)
  {
	/* copy per 1 byte */
	const char *p = src;
	char *q = dst;

	while (n--) {
	      ,*q++ = *p++;
	}

	return dst;
  }

  char *strncpy(char *dest, const char *src, size_t n)
  {
	size_t i;

	for (i = 0; i < n && src[i] != 0; i++)
	      dest[i] = src[i];
	for (; i < n; i++)
	      dest[i] = '\0';

	return dest;
  }

  char *strchr(const char *str, int c)
  {
	do {
	      if (*str == (char)c)
		    return (char *)str;
	      str++;
	} while (*str);

	return NULL;
  }

  size_t strlen(const char *str)
  {
	char *tmp = (char *)str;
	size_t counter = 0;
	while (*tmp++)
	      ++counter;
	return counter;
  }

  static void uint_to_str(unsigned int i, char *buf, int base)
  {
	char const digit_10[] = "0123456789";
	char const digit_16[] = "0123456789abcdef";
	unsigned int shifter = i;
	char const *digit;

	if (base == 10)
	      digit = digit_10;
	else
	      digit = digit_16;

	do {
	      ++buf;
	      shifter = shifter / base;
	} while (shifter);

	,*buf = '\0';

	do {
	      ,*--buf = digit[i % base];
	      i = i / base;
	} while (i);
  }

  static void int_to_str(int i, char *buf, int base)
  {
	int sign = i;

	if (i < 0) {
	      i = -i;
	      buf++;
	}

	uint_to_str((unsigned int)i, buf, base);

	if (sign < 0)
	      ,*--buf = '-';
  }

  static int isdigit(char c)
  {
	return (int)(c >= '0' && c <= '9');
  }

  static int handle_num(char type, char *buf, va_list *args)
  {
	int int_num;
	unsigned int uint_num;

	switch (type) {
	case 'u':
	      uint_num = va_arg(*args, unsigned int);
	      uint_to_str(uint_num, buf, 10);
	      break;
	case 'd':
	      int_num = va_arg(*args, int);
	      int_to_str(int_num, buf, 10);
	      break;
	case 'x':
	      uint_num = va_arg(*args, unsigned int);
	      uint_to_str(uint_num, buf, 16);
	      break;
	default:
	      return 1;
	      break;
	}

	return 0;
  }

  int vsnprintf(char *str, size_t n, const char *format, va_list args)
  {
	char *pos;
	char *s;
	char *tmp = str;
	size_t length = 0;
	int num_length, min_length;
	char num_buf[12];
	int not_implemented;

	for (pos = (char *)format; *pos != '\0'; pos++) {
	      while ((*pos != '%') && (*pos != '\0') && (length < n)) {
		    ,*tmp++ = *pos++;
		    length++;
	      }

	      if (length == n)
		    break;

	      if (*pos == '\0') {
		    ,*tmp = '\0';
		    break;
	      }

	      pos++;

	      not_implemented = 0;

	      switch (*pos) {
	      case 's':
		    s = va_arg(args, char *);
		    strncpy(tmp, s, n - length);
		    break;
	      case '0':
		    if (isdigit(*(pos + 1)) && (*(pos + 1) > '0')) {
			  pos++;
		    } else {
			  not_implemented = 1;
			  break;
		    }
	      case '1':
	      case '2':
	      case '3':
	      case '4':
	      case '5':
	      case '6':
	      case '7':
	      case '8':
	      case '9':
		    min_length = (int)(*pos - '0');

		    if (handle_num(*(pos + 1), num_buf, &args)) {
			  if (*(pos - 1) == '0')
				pos--;

			  not_implemented = 1;
			  break;
		    }

		    num_length = (int)strlen(num_buf);

		    if (num_length < min_length) {
			  while (num_length >= 0)
				num_buf[min_length--] = num_buf[num_length--];

			  if (*(pos - 1) == '0') {
				if (num_buf[0] == '-') {
				      min_length++;
				      while (min_length > 0)
					    num_buf[min_length--] = '0';
				} else {
				      while (min_length >= 0)
					    num_buf[min_length--] = '0';
				}
			  } else {
				while (min_length >= 0)
				      num_buf[min_length--] = ' ';
			  }
		    }
		    strncpy(tmp, num_buf, n - length);
		    pos++;
		    break;
	      default:
		    if (handle_num(*pos, num_buf, &args))
			  not_implemented = 1;
		    else
			  strncpy(tmp, num_buf, n - length);
		    break;
	      }

	      if (not_implemented) {
		    va_arg(args, unsigned int);
		    ,*tmp++ = '%';
		    length++;
		    pos--;
	      } else {
		    while ((*tmp != '\0') && (length < n)) {
			  tmp++;
			  length++;
		    }
	      }
	}

	if (tmp == str) {
	      ,*tmp = '\0';
	} else if (length == n) {
	      tmp--;
	      if (*tmp != '\0')
		    ,*tmp = '\0';
	      else
		    length--;
	} else if (*(tmp - 1) != '\0') {
	      ,*tmp = '\0';
	} else {
	      length--;
	}

	return (int)length;
  }

  int snprintf(char *str, size_t size, const char *format, ...)
  {
	int counter;
	va_list args;
	va_start(args, format);
	counter = vsnprintf(str, size, format, args);
	va_end(args);
	return counter;
  }

  void __assert_fail(
		     const char *assertion,
		     const char *file,
		     unsigned int line,
		     const char *function)
  {
	while (1)
	      continue;
  }
#+end_src 
不知道是arm CA和库怎么不适配了，我的板子，snprintf这类函数也需要重写才行；