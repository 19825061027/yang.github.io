#+INCLUDE: "../../prefix.org"

#+TITLE: ringbuffer aux

The mechanism for AUX ring buffer
Chapter overview:
1. It firstly concludes the relationship between the AUX ring buffer and the generic ring buffer.
2. Then it reviews how the AUX ring buffer co-work with the generic ring buffer, and
   what's the extension introduced by the AUX ring buffer for the sampling mechanism.

The RELATIONSHIP with the generic RING BUFFER
1. In an overview, the AUX ring buffer is an auxiliary for the generic ring buffer.
2. The generic ring buffer is primarily used to store the event samples, and every event format complies
   with the definition in the union perf_event;
3. The AUX ring buffer is for recording the hardware tracing, and the trace data format is hardware IP dependent.
4. The advantage of introducing AUX ring buffer is it can de-couple the data transferring between the generic
   perf events and the hardware tracing.

5. AUX ring buffer reuses the same algorithm with the generic ring buffer for the buffer management.
6. The control structure perf_event_mmap_page extends the new fields aux_head and aux_tail for the head and tail
   pointers of the AUX ring buffer.

7. The record option record_opts::auxtrace_mmap_pages is set during the  AUX trace initialisation, otherwise, if
   perf session has not attached to any AUX trace, this option is the default value '0'.
8. When it's a non-zero value, the function auxtrace_mmap__mmap() invokes system call mmap() and the kernel
   function rb_alloc_aux() serves for allocating pages; these pages will be deferred to map into VMA when detects
   the page fault which is the exactly same mechanism with the generic ring buffer.
9. As the result, the perf tool have two types of ring buffer and needs to manage every ring buffer individually.
   generic ring buffer: userpage/ringbuffer
   AUX ring buffer: userpage/ringbuffer
#+begin_src c
  // 会通过event对应的文件描述符，到这里
  // file_ops::mmap函数，负责在user通过open函数或其他拿到fd时，通过mmap，将文件偏移多少，大小多少，映射到用户空间，返回基地址
  // 而此函数，是已经分配好了虚拟地址空间，需要此函数将虚拟地址空间和磁盘物理地址空间进行映射
  static int perf_mmap(struct file *file, struct vm_area_struct *vma) {
	struct perf_event *event = file->private_data;
	unsigned long user_locked, user_lock_limit;
	struct user_struct *user = current_user();
	struct perf_buffer *rb = NULL;
	unsigned long locked, lock_limit;
	unsigned long vma_size;
	unsigned long nr_pages;

	vma_size = vma->vm_end - vma->vm_start;

	if (vma->vm_pgoff == 0) {
	      nr_pages = (vma_size / PAGE_SIZE) - 1;
	}

	ring_buffer_attach(event, NULL);

	user_extra = nr_pages + 1;

	if (!rb) {
	      rb = rb_alloc(nr_pages,
			    event->attr.watermark ? event->attr.wakeup_watermark : 0,
			    event->cpu, flags);

	      if (!rb) {
		    ret = -ENOMEM;
		    goto unlock;
	      }

	      atomic_set(&rb->mmap_count, 1);
	      rb->mmap_user = get_current_user();
	      rb->mmap_locked = extra;

	      ring_buffer_attach(event, rb);

	      perf_event_update_time(event);
	      perf_event_init_userpage(event);
	      perf_event_update_userpage(event);
	}

	vma->vm_ops = &perf_mmap_vmops;

	if (event->pmu->event_mapped)
	      event->pmu->event_mapped(event, vma->vm_mm);

	return ret;
  }
#+end_src