#+INCLUDE: "../../prefix.org"

#+TITLE: tty源码探究

open 时发现：
- 一个tty_struct对应一个设备
- 一个主设备号对应一个tty_driver，n个次设备号对应n个tty_struct，不过tty_struct是在使用时候才会进行分配，分配之后就放到tty_driver::ttys[]。
- 一个tty_ldisc对应一个tty_struct，而tty_ldisc::ops即tty_ldisc_ops是一类TTY对应一种。
  #+begin_src c
    struct tty_ldisc *ld;
    struct tty_ldisc_ops *ldops;

    ldops = tty_ldiscs[disc];
    ld = kmalloc(sizeof(struct tty_ldisc), GFP_KERNEL | __GFP_NOFAIL);
    ld->ops = ldops;

    // 其中，注册ops到静态数组的接口
    int tty_register_ldisc(struct tty_ldisc_ops *new_ldisc)
    {
	    tty_ldiscs[new_ldisc->num] = new_ldisc;
	    return 0;
    }
  #+end_src
- tty/serial/对应的是N_TTY
- tty_driver_install_tty()时：driver->ttys[tty->index] = tty;同时有tty_init_termios(tty);其中设置了tty的主要电气(baud)以及操作行为；
- 一个tty_struct对应一个tty_port，tty_port是在驱动初始化时就针对设备创建的；
- tty_struct::struct list_head tty_files; 一个tty可以对应多个fd，多个fds通过tty_files串联起来，而每个fd对应的struct file的private_data则对应的是如下结构体：
  #+begin_src c
    /* Each of a tty's open files has private_data pointing to tty_file_private */
    struct tty_file_private {
	    struct tty_struct *tty;
	    struct file *file;
	    struct list_head list;
    };
  #+end_src
- open时候，优先使用对应当前task_struct::signal::tty，也就是当前进程已有的tty，不会再打开新的；
