#+INCLUDE: "../../prefix.org"

#+TITLE: devicetree

Kernel支持一套平台无关的设备树测试用例,执行OF unittest所需的测试数据如何附着到live tree上;

* Device Tree usage
http://www.devicetree.org/Device_Tree_Usage
此文档walk through如何为一个新机器写设备树. 目标是提供设备树观念概述和如何使用他们描述一个机器;
设备树格式的详细描述查看https://elinux.org/images/c/cf/Power_ePAPR_APPROVED_v1.1.pdf
ePAPR当前采用一个新的名字进行更新: Devicetree Specification Documentation
** Basic Data Format
属性键值对:
文本字符串:
string-property="a string";
32bit无符号整数采用对角括号:
cell-property=<0xbeef 123 0xabcd1234>;
二进制数据采用方括号:
binary-property=[0x1 0x23 0x45 0x67];
代表不同类型的数据采用逗号拼接混合:
mixed-property="a string", [0x01 0x23 0x45 0x67], <0x12345678>;
逗号用来创建字符串列表:
string-list="red fish","blue fish";
** Basic Concepts
制造商 Acme || 名字 Coyote's Revenge 
- One 32bit ARM CPU
- processor local bus attached to memory mapped serial port, spi bus controller, i2c controller, interrupt controller, and external bus bridge
- 256MB of SDRAM based at 0
- 2 Serial ports based at 0x101F1000 and 0x101F2000
- GPIO controller based at 0x101F3000
- SPI controller based at 0x10170000 with following devices
  - MMC slot with SS pin attached to GPIO#1
- External bus bridge with following devices
  - SMC SMC91111 Ethernet device attached to external bus based at 0x10100000
  - i2c controller based at 0x10160000 with following devices
    - Maxim DS1338 real time clock. Responds to slave address 1101000(0x58)
  - 64MB of NOR flash based at 0x30000000

Initial structure
#+begin_src c
  /dts-v1/:
  / {
  compatible="acme,coyotes-revenge";
};
#+end_src
compatible="<manufacturer>,<model>";

CPUs
#+begin_src c
    /dts-v1/:
    / {
    compatible="acme,coyotes-revenge";

    cpus{
	  cpu@0 {
		compatible="arm,cortex-a9";
	  };
	  cpu@1 {
		compatible="arm,cortex-a9";
	  };
    };
  };
#+end_src

Node Names
<name>[@<unit-address>]
name简单ascii字符串,最多31字符.
unit-address,用来访问设备的主地址,在节点的reg属性中重复描述.
姊妹节点的命名必须唯一,但可以name相同,address不同(serial@101f1000 & serial@101f2000)

Devices
#+begin_src c
  /dts-v1/;

  / {
	compatible = "acme,coyotes-revenge";

	cpus {
	      cpu@0 {
		    compatible = "arm,cortex-a9";
	      };
	      cpu@1 {
		    compatible = "arm,cortex-a9";
	      };
	};

	serial@101F0000 {
	      compatible = "arm,pl011";
	};

	serial@101F2000 {
	      compatible = "arm,pl011";
	};

	gpio@101F3000 {
	      compatible = "arm,pl061";
	};

	interrupt-controller@10140000 {
	      compatible = "arm,pl190";
	};

	spi@10115000 {
	      compatible = "arm,pl022";
	};

	external-bus {
	      ethernet@0,0 {
		    compatible = "smc,smc91c111";
	      };

	      i2c@1,0 {
		    compatible = "acme,a1234-i2c-bus";
		    rtc@58 {
			  compatible = "maxim,ds1338";
		    };
	      };

	      flash@2,0 {
		    compatible = "samsung,k8f1315ebm", "cfi-flash";
	      };
	};
   };
#+end_src
设备树中的层级是CPU视角;
每个节点都有compatible属性;
flash节点有两个字符串;

Understanding the compatible Property
OS用compatible属性判断将哪个设备驱动绑定到设备上;
compatible是一个字符串列表,第一个字符串精准指向节点代表的设备,格式是"<manufacturer>,<model>",下一个代表设备兼容的其他设备;
如Freescale的MPC8349 Soc有一个串口设备,实现了National Semiconductor ns16550寄存器接口: compatible="fsl,mpc8349-uart","ns16550";此例中,"fsl,mpc8349-uart"指向精准设备,ns16550代表这是一个寄存器级别兼容National semiconductor 16550 UART的设备;
ns16550没有manufacturer纯粹是历史原因,所有新的兼容值需要使用采用manufacturer前缀;
** How Addressing Works
CPU addressing
#+begin_src c
  cpus {
  #address-cells = <1>;
  #size-cells = <0>;
	cpu@0 {
	      compatible = "arm,cortex-a9";
	      reg = <0>;
	};
	cpu@1 {
	      compatible = "arm,cortex-a9";
	      reg = <1>;
	};
  };
#+end_src
CPU节点可以代表最简单的用例,来说明addressing. 每一个CPU分配一个独一无二的ID,没有和id相关的size;
约定,如果节点有reg属性,那name@unit-address中的@unit-address不可省略,并且是reg属性中的第一个地址值;

Memory Mapped Devices
#+begin_src c
  /dts-v1/;

  / {
  #address-cells = <1>;
  #size-cells = <1>;

	...

	      serial@101f0000 {
	      compatible = "arm,pl011";
	      reg = <0x101f0000 0x1000 >;
	};

	serial@101f2000 {
	      compatible = "arm,pl011";
	      reg = <0x101f2000 0x1000 >;
	};

	gpio@101f3000 {
	      compatible = "arm,pl061";
	      reg = <0x101f3000 0x1000
		    0x101f4000 0x0010>;
	};

	interrupt-controller@10140000 {
	      compatible = "arm,pl190";
	      reg = <0x10140000 0x1000 >;
	};

	spi@10115000 {
	      compatible = "arm,pl022";
	      reg = <0x10115000 0x1000 >;
	};

	...

	      };
#+end_src
一些设备所在的bus有不同的地址策略. 例如,设备可以附着于一个外部bus上,此bus带有片选线.
#+begin_src c
  external-bus {
  #address-cells = <2>;
  #size-cells = <1>;

	ethernet@0,0 {
	      compatible = "smc,smc91c111";
	      reg = <0 0 0x1000>;
	};

	i2c@1,0 {
	      compatible = "acme,a1234-i2c-bus";
	      reg = <1 0 0x1000>;
	      rtc@58 {
		    compatible = "maxim,ds1338";
	      };
	};

	flash@2,0 {
	      compatible = "samsung,k8f1315ebm", "cfi-flash";
	      reg = <2 0 0x4000000>;
	};
  };
#+end_src
external-bus使用2 cells作为地址值;一个作为芯片选择号,另一个作为芯片偏移值;

Non Memory Mapped Devices
#+begin_src c
  i2c@1,0 {
	compatible = "acme,a1234-i2c-bus";
  #address-cells = <1>;
  #size-cells = <0>;
	reg = <1 0 0x1000>;
	rtc@58 {
	      compatible = "maxim,ds1338";
	      reg = <58>;
	};
  };
#+end_src
其他设备并不映射到处理器总线地址上.设备节点有地址,但不直接被CPU访问;

** How Interrupts Work
** Device Specific Data
** Special Nodes
** Advanced Topics
** Notes
* of_unittest.rst
** Test-data
drivers/of/unittest-data/testcases.dts 包含在 drivers/of/unittest.c 所需的自动测试数据;
当前,一下dts包括进了testcases.dts:
drivers/of/unittest-data/tests-interrupts.dtsi
drivers/of/unittest-data/tests-platform.dtsi
drivers/of/unittest-data/tests-phandle.dtsi
drivers/of/unittest-data/tests-match.dtsi

内核使能OF_SELFTEST后,会有以下规则:
#+begin_src makefile
  $(obj)/%.dtb: $(src)/%.dts FORCE
              $(call if_changed_dep, dtc)
#+end_src
编译testcases.dts -> testcases.dtb, 后者作为平坦DT被引用;
之后,采用以下依赖进行包裹:
#+begin_src makefile
  $(obj)/%.dtb.S: $(obj)/%.dtb
              $(call cmd, dt_S_dtb)
#+end_src
之后,*.dtb.S -> testcases.dtb.o, 后者链接进内核;
** Adding the test data
非平坦设备树结构由树结构连接的device_node组成:
#+begin_src c
  // following struct members are used to construct the tree
  struct device_node {
	...
	struct  device_node *parent;
	struct  device_node *child;
	struct  device_node *sibling;
	...
  };
#+end_src
非平坦设备树的通用结构,只考虑sibling和child指针;
parent指针用来反向遍历设备树;
    root ('/')
    |
    child1 -> sibling2 -> sibling3 -> sibling4 -> null
    |         |           |           |
    |         |           |          null
    |         |           |
    |         |        child31 -> sibling32 -> null
    |         |           |          |
    |         |          null       null
    |         |
    |      child21 -> sibling22 -> sibling23 -> null
    |         |          |            |
    |        null       null         null
    |
    child11 -> sibling12 -> sibling13 -> sibling14 -> null
    |           |           |            |
    |           |           |           null
    |           |           |
    null        null       child131 -> null
			    |
			    null

执行OF unittest前,需要将测试数据附着到机器设备树;因此,当selftest_data_add()调用时,他首先读取通过以下内核符号链接进内核镜像的平坦设备树:
    __dtb_testcases_begin - address marking the start of test data blob
    __dtb_testcases_end   - address marking the end of test data blob

之后,调用of_fdt_unflatten_tree()将平坦设备树进行非平坦化;
最后,如果机器设备树(live tree)存在.将非平坦测试数据附着进live tree,否则将自己作为一个live device tree;
attach_node_and_children() 使用 of_attach_node()将节点放进live tree中;
