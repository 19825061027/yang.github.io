#+INCLUDE: "../../prefix.org"

#+TITLE: TTY文档翻译

===
TTY
===
TTY层关心所有的串口设备。


TTY structures
===
有几种主要的TTY结构。
= N tty devices
= N struct tty_port
= 1 tty_driver
tty_driver描述了tty层驱动，同样包含一个ops指针(tty_operations)。ops用来操作TTYs。
调用open函数时，一个struct tty_struct被分配实例，直到最后close。在此期间，几个
tty_operations中的回调函数会由TTY层调用。
Kernel接收到的每个字符(来自底层硬件devices或上层用户users)经过一个预处理阶段tty_ldisc.
ldisc的任务是转换某些字符，而转换规则由ldisc或user定义。默认的一个是n_tty，实现了
echo，信号处理，任务控制，特殊字符处理等等。

tty_driver
tty_port
tty_struct
tty_ldisc
tty_buffer
tty_internals

Write TTY Driver
===
写TTY驱动之前，必须考虑Serial和USB Serial层。串口设备驱动经常使用这两个中的一个来实现
串口驱动。只有特殊设备需要直接由TTY层处理。

一个典型的TTY驱动执行顺序：
1. 分配并注册一个TTY驱动(module init)
2. 探索到TTY设备时，创建并注册(probe function)
3. 处理TTY ops和中断事件等事件(TTY core invokes the former, the device the latter)
4. 移除设备(remove function)
5. unregister and free the TTY driver(module exit)


TTY Driver and TTY Operations
===

Allocation
===
tty_driver层做的第一件事情就是由tty_alloc_driver()分配一个tty_driver。然后给新创建
的实例填充信息。

Registration
===
当tty_driver分配好并初始化填充之后，使用tty_register_driver()注册。flags参数推介使用
TTY_DRIVER_DYNAMIC_DEV。

Registering Devices
===
每一个tty设备应该有一个tty_port支持。通常，TTY驱动将tty_port嵌入到设备的私有数据结构。

翻译也不好理解，还是看代码去